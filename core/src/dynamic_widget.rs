use std::{cell::RefCell, collections::HashMap, rc::Rc};

use crate::prelude::{key::Key, widget_tree::WidgetTree, *};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::SmallVec;

#[derive(Declare)]
pub struct ExprWidget<F> {
  pub(crate) expr: F,
  pub(crate) upstream: Option<LocalBoxOp<'static, bool, ()>>,
}
/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut() -> Box<dyn Iterator<Item = Widget>>>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GeneratorID(usize);

struct GenerateInfoInner {
  id: GeneratorID,
  /// The parent of the generator.
  parent: WidgetId,
  /// widget generated by the generator.
  generated_widgets: SmallVec<[WidgetId; 1]>,
}

#[derive(Clone)]
pub(crate) struct GeneratorInfo(Rc<RefCell<GenerateInfoInner>>);

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: WidgetId,
    generated_widgets: SmallVec<[WidgetId; 1]>,
  ) -> Self {
    let inner = GenerateInfoInner { id, parent, generated_widgets };
    GeneratorInfo(Rc::new(RefCell::new(inner)))
  }

  pub(crate) fn parent(&self) -> WidgetId { self.0.borrow().parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.0.borrow().id }

  fn add_dynamic_widget_tmp_anchor(&self, tree: &mut WidgetTree) -> WidgetId {
    let inner = self.0.borrow_mut();
    let prev_sibling = inner
      .generated_widgets
      .first()
      .cloned()
      .and_then(|id| id.prev_sibling(tree));

    let holder = tree.place_holder();
    if let Some(prev_sibling) = prev_sibling {
      prev_sibling.insert_next(holder, tree)
    } else {
      inner.parent.append(holder, tree)
    }
    holder
  }
}

impl<F, R, M: ?Sized> IntoWidget<dyn FnMut() -> M> for ExprWidget<F>
where
  F: FnMut() -> R + 'static,
  R: IntoWidget<M> + 'static,
  M: 'static,
{
  fn into_widget(self) -> Widget {
    let ExprWidget { mut expr, upstream } = self;
    ExprWidget {
      expr: move || std::iter::once(expr()),
      upstream,
    }
    .into_widget()
  }
}

impl<F, R, M: ?Sized> IntoWidget<dyn Iterator<Item = M>> for ExprWidget<F>
where
  F: FnMut() -> R + 'static,
  R: Iterator + 'static,
  R::Item: IntoWidget<M>,
  M: 'static,
{
  fn into_widget(self) -> Widget {
    let ExprWidget { mut expr, upstream } = self;
    let expr = move || -> Box<dyn Iterator<Item = Widget>> {
      let iter = expr().into_iter().map(IntoWidget::into_widget);
      Box::new(iter)
    };
    let expr: Box<_> = Box::new(expr);
    Widget(WidgetInner::Expr(ExprWidget { expr, upstream }))
  }
}

impl Generator {
  // todo: update method can provide by use case? like margin with if
  // guard, can directly replace widget not instead of whole subtree.
  #[inline]
  pub(crate) fn update_generated_widgets(&mut self, ctx: &mut Context) {
    let new_widgets_iter = (self.expr)();

    let tmp_anchor = self.info.add_dynamic_widget_tmp_anchor(ctx.tree_mut());
    let mut info = self.info.0.borrow_mut();
    let mut key_widgets = info
      .generated_widgets
      .iter()
      .filter_map(|id| {
        let tree = ctx.tree_mut();
        if let Some(key) = id
          .assert_get(tree)
          .query_first_type::<Key>(QueryOrder::OutsideFirst)
          .cloned()
        {
          id.detach(tree);
          Some((key.clone(), *id))
        } else {
          ctx.drop_subtree(*id);
          None
        }
      })
      .collect::<HashMap<_, _, ahash::RandomState>>();
    info.generated_widgets.clear();

    new_widgets_iter
      .into_iter()
      .fold(tmp_anchor, |insert_at, c| {
        let id = info.parent.insert_child(
          c,
          &mut |node, tree| {
            let old = node
              .query_first_type::<Key>(QueryOrder::OutsideFirst)
              .and_then(|k| key_widgets.remove(k));
            let id = match old {
              Some(c_id) => {
                *c_id.assert_get_mut(tree) = node;
                c_id
              }
              None => tree.new_node(node),
            };
            insert_at.insert_next(id, tree);
            id
          },
          &mut |wid, child, ctx| {
            wid.append_widget(child, ctx);
          },
          ctx,
        );
        info.generated_widgets.push(id);
        id
      });

    key_widgets
      .into_iter()
      .for_each(|(_, k)| ctx.drop_subtree(k));
    ctx.drop_subtree(tmp_anchor);
  }

  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}
