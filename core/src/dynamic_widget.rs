use std::collections::HashMap;

use crate::prelude::{key::Key, widget_tree::WidgetTree, *};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::SmallVec;

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<R> {
  #[declare(convert = box_trait(FnMut(&mut dyn FnMut(Widget)) -> R))]
  pub(crate) expr: Box<dyn FnMut(&mut dyn FnMut(Widget)) -> R>,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared  `ExprWidget` which but its
/// expression not following anything.
#[derive(Declare)]
pub struct ConstExprWidget<W> {
  #[allow(unused)]
  pub(crate) expr: W,
}

/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut(&mut dyn FnMut(Widget))>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub(crate) struct GeneratorID(usize);

pub struct GeneratorInfo {
  id: GeneratorID,
  /// The parent of the generator.
  parent: Option<WidgetId>,
  /// widget generated by the generator.
  generated_widgets: SmallVec<[WidgetId; 1]>,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: Option<WidgetId>,
    generated_widgets: SmallVec<[WidgetId; 1]>,
  ) -> Self {
    GeneratorInfo { id, parent, generated_widgets }
  }

  pub(crate) fn parent(&self) -> Option<WidgetId> { self.parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.id }
}

impl IntoWidget<SingleConsumer> for ExprWidget<SingleConsumer> {
  #[inline]
  fn into_widget(self) -> Widget {
    // #Safety
    // Only erase the function return type `SingleConsumer` which is unit struct
    Widget(WidgetInner::Expr(unsafe { std::mem::transmute(self) }))
  }
}

impl IntoWidget<MultiConsumer> for ExprWidget<MultiConsumer> {
  #[inline]
  fn into_widget(self) -> Widget {
    // #Safety
    // Only erase the function return type `MultiConsumer` which is unit struct
    Widget(WidgetInner::Expr(unsafe { std::mem::transmute(self) }))
  }
}

impl Generator {
  #[inline]
  pub(crate) fn update_generated_widgets(&mut self, tree: &mut WidgetTree) {
    let Self { info, expr } = self;

    let mut cursor = GeneratorCursor::new(&info, tree);
    let mut key_widgets = info
      .generated_widgets
      .drain(..)
      .filter_map(|id| {
        let mut key = None;
        id.assert_get(tree)
          .query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
            key = Some(k.clone());
          });
        if let Some(key) = key {
          id.detach(tree);
          Some((key.clone(), id))
        } else {
          id.remove_subtree(tree);
          None
        }
      })
      .collect::<HashMap<_, _, ahash::RandomState>>();

    expr(&mut |c| {
      tree.insert_widget_to(info.parent, c, |node, tree| {
        let mut old = None;
        node.query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
          old = key_widgets.remove(k);
        });

        let id = if let Some(id) = old {
          *id.assert_get_mut(tree) = node;
          id
        } else {
          tree.new_node(node)
        };

        cursor.add(id, tree);
        tree.mark_dirty(id);
        info.generated_widgets.push(id);
        if old.is_none() {
          id.on_mounted(tree);
        }
        id
      });
    });
    key_widgets
      .into_iter()
      .for_each(|(_, k)| k.remove_subtree(tree));

    if info.generated_widgets.is_empty() {
      // add void widget for generator, so we can always know where to replace dynamic
      // widget.
      let road_sign = tree.new_node(Box::new(Void));
      info.generated_widgets.push(road_sign);
      cursor.add(road_sign, tree);
    }
  }

  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}

enum GeneratorCursor {
  ParentFirstChild(WidgetId),
  SiblingOf(WidgetId),
  AsRoot,
  MultiRoot,
}

impl GeneratorCursor {
  fn new(info: &GeneratorInfo, tree: &WidgetTree) -> Self {
    if let Some(prev) = info
      .generated_widgets
      .first()
      .and_then(|l| l.prev_sibling(tree))
    {
      Self::SiblingOf(prev)
    } else if let Some(p) = info.parent() {
      Self::ParentFirstChild(p)
    } else {
      Self::AsRoot
    }
  }

  fn add(&mut self, id: WidgetId, tree: &mut WidgetTree) {
    match self {
      GeneratorCursor::ParentFirstChild(p) => {
        if let Some(s) = p.first_child(tree) {
          s.insert_before(id, tree);
        } else {
          p.append(id, tree);
        }
        *self = GeneratorCursor::SiblingOf(id)
      }
      GeneratorCursor::SiblingOf(sibling) => {
        sibling.insert_after(id, tree);
        *sibling = id;
      }
      GeneratorCursor::AsRoot => {
        tree.set_root(id);
        *self = GeneratorCursor::MultiRoot;
      }
      GeneratorCursor::MultiRoot => {
        panic!("ExprWidget as root, but generate more than once widget.")
      }
    }
  }
}
