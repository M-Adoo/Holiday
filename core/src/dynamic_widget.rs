use std::collections::HashMap;

use crate::{
  impl_proxy_query,
  prelude::{key::Key, widget_tree::WidgetTree, *},
};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::SmallVec;

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<E> {
  pub(crate) expr: E,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared  `ExprWidget` which but its
/// expression not following anything.
#[derive(Declare)]
pub struct ConstExprWidget<W> {
  #[allow(unused)]
  pub(crate) expr: W,
}

/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut() -> ExprResult>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub(crate) struct GeneratorID(usize);

pub struct GeneratorInfo {
  id: GeneratorID,
  /// The parent of the generator.
  parent: Option<WidgetId>,
  /// widget generated by the generator.
  generated_widgets: SmallVec<[WidgetId; 1]>,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: Option<WidgetId>,
    generated_widgets: SmallVec<[WidgetId; 1]>,
  ) -> Self {
    GeneratorInfo { id, parent, generated_widgets }
  }

  pub(crate) fn parent(&self) -> Option<WidgetId> { self.parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.id }
}

pub enum ExprResult {
  Single(Option<Widget>),
  Multi(Vec<Widget>),
}
pub struct SingleResult<W>(Option<W>);
pub struct MultiResult(Vec<Widget>);

pub trait IntoGenResult<M: ?Sized> {
  type G;
  fn into_gen_result(self) -> Self::G;
}

impl<W, M: ?Sized> IntoGenResult<&M> for W
where
  W: IntoWidget<M>,
{
  type G = SingleResult<W>;

  #[inline]
  fn into_gen_result(self) -> Self::G { SingleResult(Some(self)) }
}

impl<W, M: ?Sized> IntoGenResult<Option<&M>> for Option<W>
where
  W: IntoWidget<M>,
{
  type G = SingleResult<W>;

  #[inline]
  fn into_gen_result(self) -> Self::G { SingleResult(self) }
}

impl<I, M: ?Sized> IntoGenResult<Vec<&M>> for I
where
  I: Iterator,
  I::Item: IntoWidget<M>,
{
  type G = MultiResult;
  #[inline]
  fn into_gen_result(self) -> Self::G { MultiResult(self.map(IntoWidget::into_widget).collect()) }
}

impl<E: 'static> ExprWidget<E> {
  pub fn into_widget<R, M: ?Sized>(self) -> Widget
  where
    E: FnMut() -> SingleResult<R>,
    R: IntoWidget<M>,
  {
    let Self { mut expr, upstream } = self;
    let expr = Box::new(move || expr().into_dyn_result());
    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget { expr, upstream })),
      children: Children::None,
    }
  }
}

impl<E: FnMut() -> MultiResult + 'static> ExprWidget<E> {
  #[inline]
  pub fn into_multi_child(self) -> Widget {
    let Self { mut expr, upstream } = self;
    let expr: Box<dyn FnMut() -> ExprResult> = Box::new(move || expr().into_dyn_result());

    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget { expr, upstream })),
      children: Children::None,
    }
  }
}

impl<R: SingleChild, E> SingleChild for ExprWidget<E> where E: FnMut() -> SingleResult<R> {}
impl<R: MultiChild, E> MultiChild for ExprWidget<E> where E: FnMut() -> SingleResult<R> {}

impl<C: SingleChild> SingleChild for ConstExprWidget<Option<C>> {}
impl<C: SingleChild> SingleChild for ConstExprWidget<C> {}
impl<C: MultiChild> MultiChild for ConstExprWidget<C> {}
impl<C: ComposeSingleChild> ComposeSingleChild for ConstExprWidget<C> {
  fn compose_single_child(this: StateWidget<Self>, child: Widget, ctx: &mut BuildCtx) -> Widget {
    match this {
      StateWidget::Stateless(c) => {
        ComposeSingleChild::compose_single_child(c.expr.into(), child, ctx)
      }
      StateWidget::Stateful(_) => unreachable!("ExprWidget should not be stateful."),
    }
  }
}
impl<C: ComposeMultiChild> ComposeMultiChild for ConstExprWidget<C> {
  fn compose_multi_child(
    this: StateWidget<Self>,
    children: Vec<Widget>,
    ctx: &mut BuildCtx,
  ) -> Widget {
    match this {
      StateWidget::Stateless(c) => {
        ComposeMultiChild::compose_multi_child(c.expr.into(), children, ctx)
      }
      StateWidget::Stateful(_) => unreachable!("ExprWidget should not be stateful."),
    }
  }
}

impl<W: Render + 'static> Render for ConstExprWidget<W> {
  #[inline]
  fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size {
    self.expr.perform_layout(clamp, ctx)
  }

  #[inline]
  fn only_sized_by_parent(&self) -> bool { self.expr.only_sized_by_parent() }

  #[inline]
  fn paint(&self, ctx: &mut PaintingCtx) { self.expr.paint(ctx) }
}

impl<W: Compose> Compose for ConstExprWidget<W> {
  fn compose(this: StateWidget<Self>, ctx: &mut BuildCtx) -> Widget {
    let w = match this {
      StateWidget::Stateless(s) => StateWidget::Stateless(s.expr),
      StateWidget::Stateful(_) => unreachable!(),
    };
    Compose::compose(w, ctx)
  }
}

impl IntoWidget<Widget> for ConstExprWidget<Widget> {
  #[inline]
  fn into_widget(self) -> Widget { self.expr }
}
impl<W: Query> Query for ConstExprWidget<W> {
  impl_proxy_query!(expr);
}

impl Generator {
  #[inline]
  pub(crate) fn update_generated_widgets(&mut self, tree: &mut WidgetTree) {
    DynamicWidgetRefresh::new(self, tree).refresh()
  }

  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}

enum GeneratorCursor {
  ParentFirstChild(WidgetId),
  SiblingOf(WidgetId),
  AsRoot,
  MultiRoot,
}

impl GeneratorCursor {
  fn new(info: &GeneratorInfo, tree: &WidgetTree) -> Self {
    if let Some(prev) = info
      .generated_widgets
      .first()
      .and_then(|l| l.prev_sibling(tree))
    {
      Self::SiblingOf(prev)
    } else if let Some(p) = info.parent() {
      Self::ParentFirstChild(p)
    } else {
      Self::AsRoot
    }
  }

  fn add(&mut self, id: WidgetId, tree: &mut WidgetTree) {
    match self {
      GeneratorCursor::ParentFirstChild(p) => {
        if let Some(s) = p.first_child(tree) {
          s.insert_before(id, tree);
        } else {
          p.append(id, tree);
        }
        *self = GeneratorCursor::SiblingOf(id)
      }
      GeneratorCursor::SiblingOf(sibling) => {
        sibling.insert_after(id, tree);
        *sibling = id;
      }
      GeneratorCursor::AsRoot => {
        tree.set_root_id(id);
        *self = GeneratorCursor::MultiRoot;
      }
      GeneratorCursor::MultiRoot => {
        panic!("ExprWidget as root, but generate more than once widget.")
      }
    }
    tree.mark_dirty(id);
  }
}

impl<W> SingleResult<W> {
  #[inline]
  fn into_dyn_result<M: ?Sized>(self) -> ExprResult
  where
    W: IntoWidget<M>,
  {
    ExprResult::Single(self.0.map(IntoWidget::into_widget))
  }
}

impl MultiResult {
  #[inline]
  fn into_dyn_result(self) -> ExprResult { ExprResult::Multi(self.0) }
}

struct DynamicWidgetRefresh<'a> {
  cursor: GeneratorCursor,
  tree: &'a mut WidgetTree,
  key_widgets: HashMap<Key, WidgetId, ahash::RandomState>,
  pairs: Vec<(WidgetId, Widget)>,
  generator: &'a mut Generator,
}

impl<'a> DynamicWidgetRefresh<'a> {
  fn new(generator: &'a mut Generator, tree: &'a mut WidgetTree) -> Self {
    let cursor = GeneratorCursor::new(generator.info(), tree);
    let key_widgets = generator
      .info
      .generated_widgets
      .drain(..)
      .filter_map(|id| {
        let mut key = None;
        id.assert_get(tree)
          .query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
            key = Some(k.clone());
          });
        if let Some(key) = key {
          id.detach(tree);
          Some((key.clone(), id))
        } else {
          id.remove_subtree(tree);
          None
        }
      })
      .collect();
    Self {
      cursor,
      tree,
      key_widgets,
      pairs: vec![],
      generator,
    }
  }

  fn refresh(&mut self) {
    let parent = self.generator.info.parent();
    match (self.generator.expr)() {
      ExprResult::Single(w) => {
        if let Some(w) = w {
          self.add_dynamic_widget(w, parent);
        }
      }
      ExprResult::Multi(m) => m
        .into_iter()
        .for_each(|w| self.add_dynamic_widget(w, parent)),
    };

    let Self {
      cursor,
      tree,
      pairs,
      generator,
      key_widgets,
    } = self;

    key_widgets
      .into_iter()
      .for_each(|(_, k)| k.remove_subtree(tree));

    if generator.info.generated_widgets.is_empty() {
      // add void widget for generator, so we can always know where to replace dynamic
      // widget.
      let road_sign = tree.new_node(Box::new(Void));
      generator.info.generated_widgets.push(road_sign);
      cursor.add(road_sign, tree);
    }
    tree.prepend_pairs(pairs);
  }

  fn add_dynamic_widget(&mut self, widget: Widget, parent: Option<WidgetId>) {
    let Self {
      cursor, tree, key_widgets, generator, ..
    } = self;
    let (id, children) = widget.consume_node(
      parent,
      |render, tree| {
        let mut old = None;
        render.query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
          old = key_widgets.remove(k);
        });

        let id = if let Some(id) = old {
          *id.assert_get_mut(tree) = render;
          id
        } else {
          tree.new_node(render)
        };
        cursor.add(id, tree);
        generator.info.generated_widgets.push(id);
        if old.is_none() {
          id.on_mounted(tree);
        }
        id
      },
      tree,
    );

    if let Some(id) = id {
      children.for_each(|w| self.pairs.push((id, w)));
    } else {
      children.for_each(move |w| self.add_dynamic_widget(w, parent))
    }
  }
}
