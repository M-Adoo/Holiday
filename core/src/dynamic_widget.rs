use crate::{impl_proxy_query, impl_query_self_only, prelude::*, widget_tree::WidgetTree};
use std::{cell::RefCell, rc::Rc};

/// the information of a widget generated by `DynWidget`.
pub(crate) enum DynWidgetGenInfo {
  /// DynWidget generate single result, and have static children. The depth
  /// describe the distance from first dynamic widget (self) to the static
  /// child.
  DynDepth(usize),
  /// `DynWidget` without static children, and the whole subtree of generated
  /// widget are dynamic widgets. The value record how many dynamic siblings
  /// have.
  WholeSubtree(usize),
}

/// Widget that as a container of dynamic widgets

#[derive(Declare)]
pub struct DynWidget<D> {
  #[declare(convert=custom)]
  pub(crate) dyns: Option<D>,
}

impl<D> DynWidgetBuilder<D> {
  pub fn dyns(mut self, d: D) -> Self {
    self.dyns = Some(Some(d));
    self
  }
}

impl<D> DynWidget<D> {
  pub fn set_declare_dyns(&mut self, dyns: D) { self.dyns = Some(dyns); }

  pub(crate) fn into_inner(mut self) -> D {
    self
      .dyns
      .take()
      .unwrap_or_else(|| unreachable!("stateless `DynWidget` must be initialized."))
  }
}

/// Widget help to limit which `DynWidget` can be a parent widget and which can
/// be a child.
pub(crate) struct DynRender<D> {
  dyn_widgets: Stateful<DynWidget<D>>,
  self_render: RefCell<Box<dyn Render>>,
  gen_info: RefCell<Option<DynWidgetGenInfo>>,
  cast_to_vec: fn(D) -> Vec<Widget>,
}

// A dynamic widget must be stateful, depends others.
impl<D: 'static> Render for DynRender<D> {
  fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size {
    self.regen_if_need(ctx);
    self.self_render.perform_layout(clamp, ctx)
  }

  fn paint(&self, ctx: &mut PaintingCtx) { self.self_render.paint(ctx) }

  fn only_sized_by_parent(&self) -> bool { self.self_render.only_sized_by_parent() }

  fn hit_test(&self, ctx: &TreeCtx, pos: Point) -> HitTest { self.self_render.hit_test(ctx, pos) }

  fn can_overflow(&self) -> bool { self.self_render.can_overflow() }
}

impl<D> DynRender<D> {
  fn new(dyns: Stateful<DynWidget<D>>, cast_to_vec: fn(D) -> Vec<Widget>) -> Self {
    Self {
      dyn_widgets: dyns,
      self_render: RefCell::new(Box::new(Void)),
      gen_info: <_>::default(),
      cast_to_vec,
    }
  }

  fn from_single<M>(dyns: Stateful<DynWidget<D>>) -> Self
  where
    M: WidgetMarker,
    D: IntoWidget<M>,
  {
    DynRender::new(dyns, |d| vec![d.into_widget()])
  }

  fn from_multi<M>(dyns: Stateful<DynWidget<D>>) -> Self
  where
    M: WidgetMarker,
    D: IntoIterator,
    D::Item: IntoWidget<M>,
  {
    DynRender::new(dyns, |d| {
      d.into_iter().map(IntoWidget::into_widget).collect()
    })
  }
}

impl<D> DynRender<Option<D>> {
  pub(crate) fn from_option_single<M>(dyns: Stateful<DynWidget<Option<D>>>) -> Self
  where
    M: WidgetMarker,
    D: IntoWidget<M>,
  {
    DynRender::new(dyns, |d| {
      d.map_or_else(Vec::default, |d| vec![d.into_widget()])
    })
  }
}

impl<D: 'static> Query for DynRender<D> {
  impl_proxy_query!(self.self_render, self.dyn_widgets);
}
impl<D: 'static> Query for DynWidget<D> {
  impl_query_self_only!();
}

impl<D> DynRender<D> {
  fn regen_if_need(&self, ctx: &mut LayoutCtx) {
    let mut dyn_widget = self.dyn_widgets.silent_ref();
    let Some(new_widgets) = dyn_widget.dyns.take() else {
      return
    };

    let mut gen_info = self.gen_info.borrow_mut();
    let mut gen_info = gen_info.get_or_insert_with(|| {
      if ctx.has_child() {
        DynWidgetGenInfo::DynDepth(1)
      } else {
        DynWidgetGenInfo::WholeSubtree(1)
      }
    });

    let sign = ctx.id;
    let tree = &mut ctx.tree;
    let current_theme = sign
      .parent(tree)
      .and_then(|s| {
        s.ancestors(tree).find_map(|id| {
          let mut theme = None;
          id.assert_get(tree)
            .query_on_first_type(QueryOrder::InnerFirst, |t: &Rc<Theme>| {
              theme = Some(t.clone());
            });
          theme
        })
      })
      .unwrap_or_else(|| tree.app_ctx().app_theme.clone());

    let mut new_widgets = (self.cast_to_vec)(new_widgets)
      .into_iter()
      .filter_map(|w| w.into_subtree(None, tree, current_theme.clone()))
      .collect::<Vec<_>>();
    if new_widgets.is_empty() {
      new_widgets.push(tree.empty_node());
    }

    // Place the real old render in node, the dyn render in node keep.
    std::mem::swap(
      &mut *self.self_render.borrow_mut(),
      sign.assert_get_mut(tree),
    );

    // swap the new sign and old, so we can always keep the sign id not change.
    sign.swap_id(new_widgets[0], tree);
    let old_sign = new_widgets[0];
    new_widgets[0] = sign;

    match &mut gen_info {
      DynWidgetGenInfo::DynDepth(depth) => {
        assert_eq!(new_widgets.len(), 1);

        let declare_child_parent = single_down(old_sign, tree, *depth as isize - 1);
        let (new_leaf, down_level) = down_to_leaf(sign, tree);

        let new_depth = down_level + 1;
        if let Some(declare_child_parent) = declare_child_parent {
          // Safety: control two subtree not intersect.
          let (tree1, tree2) = unsafe { tree.split_tree() };
          declare_child_parent
            .children(tree1)
            .for_each(|c| new_leaf.append(c, tree2));
        }

        old_sign.insert_after(sign, tree);
        old_sign.remove_subtree(tree);
        single_on_mounted(sign, new_depth, tree);

        *depth = new_depth;
      }

      DynWidgetGenInfo::WholeSubtree(siblings) => {
        let mut cursor = old_sign;
        new_widgets.iter().rev().for_each(|n| {
          cursor.insert_before(*n, tree);
          cursor = *n;
        });

        let mut remove = Some(old_sign);
        (0..*siblings).for_each(|_| {
          let o = remove.unwrap();
          remove = o.next_sibling(tree);
          o.remove_subtree(tree);
        });

        new_widgets.iter().for_each(|n| {
          n.on_mounted_subtree(tree);
        });
        *siblings = new_widgets.len();
      }
    };
    // Place the dynRender back in node.
    std::mem::swap(
      &mut *self.self_render.borrow_mut(),
      sign.assert_get_mut(tree),
    );
  }
}

fn single_down(id: WidgetId, tree: &WidgetTree, mut down_level: isize) -> Option<WidgetId> {
  let mut res = Some(id);
  while down_level > 0 {
    down_level -= 1;
    res = res.unwrap().single_child(tree);
  }
  res
}

fn down_to_leaf(id: WidgetId, tree: &WidgetTree) -> (WidgetId, usize) {
  let mut leaf = id;
  let mut depth = 0;
  while let Some(c) = leaf.single_child(tree) {
    leaf = c;
    depth += 1;
  }
  (leaf, depth)
}

fn single_on_mounted(from: WidgetId, mut level: usize, tree: &mut WidgetTree) -> Option<WidgetId> {
  let mut next = Some(from);
  while level > 0 {
    let c = next.unwrap();
    c.on_mounted(tree);
    next = c.single_child(tree);

    level -= 1;
  }
  next
}

// impl IntoWidget

// only `DynWidget` gen single widget can as a widget.
impl<D, M> IntoWidget<FromOther<M>> for Stateful<DynWidget<D>>
where
  M: WidgetMarker,
  D: IntoWidget<M> + 'static,
{
  #[inline]
  fn into_widget(self) -> Widget { DynRender::from_single(self).into_widget() }
}

impl<D> Stateful<DynWidget<Option<D>>> {
  #[inline]
  pub fn into_widget<M>(self) -> Widget
  where
    M: WidgetMarker,
    D: IntoWidget<M> + 'static,
  {
    DynRender::from_option_single(self).into_widget()
  }
}

impl<D, M> IntoWidget<FromOther<M>> for DynWidget<D>
where
  M: WidgetMarker,
  D: IntoWidget<M> + 'static,
{
  #[inline]
  fn into_widget(self) -> Widget { self.into_inner().into_widget() }
}

// impl IntoChild
impl<D, M> IntoChild<FromOther<DynWidget<M>>, Widget> for Stateful<DynWidget<D>>
where
  M: WidgetMarker,
  D: IntoIterator + 'static,
  D::Item: IntoWidget<M>,
{
  #[inline]
  fn into_child(self) -> Widget { DynRender::from_multi(self).into_widget() }
}

// // Iterator -> Vec<C>
// // Iterator can only provide across DynWidget.
impl<Iter, C, M> FillChildVec<DynWidget<M>, C> for DynWidget<Iter>
where
  Iter: IntoIterator,
  M: ChildMarker,
  Iter::Item: IntoChild<M, C>,
{
  #[inline]
  fn fill(self, vec: &mut Vec<C>) {
    vec.extend(self.into_inner().into_iter().map(IntoChild::into_child))
  }
}

// // impl WithChild

impl<D, C, M1, M2> WithChild<(&dyn SingleChild, &M1, &M2), C> for Stateful<DynWidget<D>>
where
  D: SingleChild + IntoWidget<M1> + 'static,
  C: IntoChild<M2, Option<Widget>>,
  M1: WidgetMarker,
  M2: ChildMarker,
{
  type Target = Widget;
  fn with_child(self, child: C) -> Self::Target {
    let render = DynRender::from_single(self);
    Widget {
      node: Some(WidgetNode::Render(Box::new(render))),
      children: child.into_child().into_iter().collect(),
    }
  }
}

impl<D, C, M1, M2> WithChild<(&dyn SingleChild, &M1, &M2), C> for Stateful<DynWidget<Option<D>>>
where
  D: SingleChild + IntoWidget<M1> + 'static,
  C: IntoChild<M2, Option<Widget>>,
  M1: WidgetMarker,
  M2: ChildMarker,
{
  type Target = Widget;
  fn with_child(self, child: C) -> Self::Target {
    let render = DynRender::from_option_single(self);

    Widget {
      node: Some(WidgetNode::Render(Box::new(render))),
      children: child.into_child().into_iter().collect(),
    }
  }
}

impl<D, C, M1, M2> WithChild<(&dyn MultiChild, &M1, &M2), C> for Stateful<DynWidget<D>>
where
  D: MultiChild + IntoWidget<M1> + 'static,
  C: IntoChild<M2, Vec<Widget>>,
  M1: WidgetMarker,
  M2: ChildMarker,
{
  type Target = Widget;
  fn with_child(self, child: C) -> Self::Target {
    let render = DynRender::from_single(self);
    Widget {
      node: Some(WidgetNode::Render(Box::new(render))),
      children: child.into_child(),
    }
  }
}

impl<C, D, M: ?Sized> WithChild<M, C> for DynWidget<D>
where
  D: WithChild<M, C>,
{
  type Target = D::Target;

  #[inline]
  fn with_child(self, child: C) -> Self::Target { self.into_inner().with_child(child) }
}

#[cfg(test)]
mod tests {
  use crate::{prelude::*, test::*, widget_tree::WidgetTree};

  #[test]
  fn expr_widget_as_root() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      DynWidget {
        dyns: MockBox { size: size.clone() },
        Void {}
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_ready(Size::zero());
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 2);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_ready(Size::zero());
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 2);

    assert_eq!(ids[1], new_ids[1]);
  }

  #[test]
  fn expr_widget_with_declare_child() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      MockBox {
        size: Size::zero(),
        DynWidget {
          dyns: MockBox { size: size.clone() },
          Void {}
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_ready(Size::zero());
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 3);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_ready(Size::zero());
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 3);

    assert_eq!(ids[0], new_ids[0]);
    assert_eq!(ids[2], new_ids[2]);
  }

  #[test]
  fn expr_widget_mounted_new() {
    let v = vec![1, 2, 3].into_stateful();

    let new_cnt = 0.into_stateful();
    let drop_cnt = 0.into_stateful();
    let w = widget! {
      track {
        v: v.clone(),
        new_cnt: new_cnt.clone(),
        drop_cnt: drop_cnt.clone(),
      }

      MockMulti { DynWidget {
        dyns: {
          v.iter().map(move |_| {
            widget! {
              MockBox{
                size: Size::zero(),
                mounted: move |_| *new_cnt += 1,
                disposed: move |_| *drop_cnt += 1
              }
            }
          }).collect::<Vec<_>>()
        }
      }}
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_ready(Size::zero());
    assert_eq!(*new_cnt.raw_ref(), 3);
    assert_eq!(*drop_cnt.raw_ref(), 0);

    v.state_ref().push(4);
    tree.tree_ready(Size::zero());
    assert_eq!(*new_cnt.raw_ref(), 7);
    assert_eq!(*drop_cnt.raw_ref(), 3);

    v.state_ref().pop();
    tree.tree_ready(Size::zero());
    assert_eq!(*new_cnt.raw_ref(), 10);
    assert_eq!(*drop_cnt.raw_ref(), 7);
  }
}
