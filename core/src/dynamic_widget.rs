use std::collections::HashMap;

use crate::prelude::{key::Key, widget_tree::WidgetTree, *};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::SmallVec;

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<R> {
  #[declare(custom_convert)]
  pub(crate) expr: Box<dyn FnMut(&mut dyn FnMut(Widget)) -> R>,
  pub(crate) upstream: Option<LocalBoxOp<'static, bool, ()>>,
}
/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut(&mut dyn FnMut(Widget))>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub(crate) struct GeneratorID(usize);

pub struct GeneratorInfo {
  id: GeneratorID,
  /// The parent of the generator.
  parent: WidgetId,
  /// widget generated by the generator.
  generated_widgets: SmallVec<[WidgetId; 1]>,
}

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: WidgetId,
    generated_widgets: SmallVec<[WidgetId; 1]>,
  ) -> Self {
    GeneratorInfo { id, parent, generated_widgets }
  }

  pub(crate) fn parent(&self) -> WidgetId { self.parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.id }

  fn add_dynamic_widget_tmp_anchor(&self, tree: &mut WidgetTree) -> WidgetId {
    let prev_sibling = self
      .generated_widgets
      .first()
      .cloned()
      .and_then(|id| id.prev_sibling(tree));

    let holder = tree.place_holder();
    if let Some(prev_sibling) = prev_sibling {
      prev_sibling.insert_next(holder, tree)
    } else {
      self.parent.append(holder, tree)
    }
    holder
  }
}

impl IntoWidget<SingleConsumer> for ExprWidget<SingleConsumer> {
  #[inline]
  fn into_widget(self) -> Widget {
    // #Safety
    // Only erase the function return type `SingleConsumer` which is unit struct
    Widget(WidgetInner::Expr(unsafe { std::mem::transmute(self) }))
  }
}

impl IntoWidget<MultiConsumer> for ExprWidget<MultiConsumer> {
  #[inline]
  fn into_widget(self) -> Widget {
    // #Safety
    // Only erase the function return type `MultiConsumer` which is unit struct
    Widget(WidgetInner::Expr(unsafe { std::mem::transmute(self) }))
  }
}

impl Generator {
  #[inline]
  pub(crate) fn update_generated_widgets(&mut self, ctx: &mut Context) {
    let Self { info, expr } = self;
    let tmp_anchor = info.add_dynamic_widget_tmp_anchor(ctx.tree_mut());
    let mut insert_at = tmp_anchor;

    let GeneratorInfo { parent, generated_widgets, .. } = info;
    let mut key_widgets = generated_widgets
      .drain(..)
      .filter_map(|id| {
        let tree = ctx.tree_mut();
        let mut key = None;
        id.assert_get(tree)
          .query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
            key = Some(k.clone());
          });
        if let Some(key) = key {
          id.detach(tree);
          Some((key.clone(), id))
        } else {
          ctx.drop_subtree(id);
          None
        }
      })
      .collect::<HashMap<_, _, ahash::RandomState>>();

    expr(&mut |c| {
      let id = parent.insert_child(
        c,
        &mut |node, tree| {
          let mut old = None;
          node.query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
            old = key_widgets.remove(k);
          });
          let id = match old {
            Some(c_id) => {
              *c_id.assert_get_mut(tree) = node;
              c_id
            }
            None => tree.new_node(node),
          };
          insert_at.insert_next(id, tree);
          id
        },
        &mut |wid, child, ctx| {
          wid.append_widget(child, ctx);
        },
        ctx,
      );
      generated_widgets.push(id);
      insert_at = id;
    });

    key_widgets
      .into_iter()
      .for_each(|(_, k)| ctx.drop_subtree(k));
    ctx.drop_subtree(tmp_anchor);
  }

  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}

impl<R> ExprWidgetBuilder<R> {
  #[inline]
  pub fn expr_convert<F>(func: F) -> Box<dyn FnMut(&mut dyn FnMut(Widget)) -> R>
  where
    F: FnMut(&mut dyn FnMut(Widget)) -> R + 'static,
  {
    Box::new(func)
  }
}
