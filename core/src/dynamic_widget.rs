use crate::{
  impl_proxy_query,
  prelude::{widget_tree::WidgetTree, *},
};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::{smallvec, SmallVec};

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<E> {
  pub(crate) expr: E,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared  `ExprWidget` which but its
/// expression not following anything.
#[derive(Declare)]
pub struct ConstExprWidget<W> {
  #[allow(unused)]
  pub(crate) expr: W,
}

/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut() -> ExprResult>,
  pub(crate) _upstream_handle: SubscriptionGuard<Box<dyn SubscriptionLike>>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub(crate) struct GeneratorID(usize);

/// the information of a widget generated by `ExprWidget`.
pub(crate) enum DynamicWidgetInfo {
  /// ExprWidget generate single result,  and have static children. The depth
  /// describe the count from first dynamic widget to the static child.
  SingleDynWithChild { gen_root: WidgetId, depth: usize },
  /// Whole subtree is generated by `ExprWidget`.
  WholeSubtree(SmallVec<[WidgetId; 1]>),
}
pub struct GeneratorInfo {
  id: GeneratorID,
  /// The parent of the generator.
  parent: Option<WidgetId>,
  /// widget generated by the generator.
  gen_dyn_widgets: DynamicWidgetInfo,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: Option<WidgetId>,
    road_sign: WidgetId,
    has_child: bool,
  ) -> Self {
    let gen_dyn_widgets = if has_child {
      DynamicWidgetInfo::SingleDynWithChild { gen_root: road_sign, depth: 1 }
    } else {
      DynamicWidgetInfo::WholeSubtree(smallvec![road_sign])
    };
    GeneratorInfo { id, parent, gen_dyn_widgets }
  }

  pub(crate) fn parent(&self) -> Option<WidgetId> { self.parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.id }
}

pub enum ExprResult {
  Single(Option<Widget>),
  Multi(Vec<Widget>),
}
pub struct SingleResult<W>(Option<W>);
pub struct MultiResult(Vec<Widget>);

pub trait IntoGenResult<M: ?Sized> {
  type G;
  fn into_gen_result(self) -> Self::G;
}

impl<W, M: ?Sized> IntoGenResult<&M> for W
where
  W: IntoWidget<M>,
{
  type G = SingleResult<W>;

  #[inline]
  fn into_gen_result(self) -> Self::G { SingleResult(Some(self)) }
}

impl<W, M: ?Sized> IntoGenResult<Option<&M>> for Option<W>
where
  W: IntoWidget<M>,
{
  type G = SingleResult<W>;

  #[inline]
  fn into_gen_result(self) -> Self::G { SingleResult(self) }
}

impl<I, M: ?Sized> IntoGenResult<Vec<&M>> for I
where
  I: Iterator,
  I::Item: IntoWidget<M>,
{
  type G = MultiResult;
  #[inline]
  fn into_gen_result(self) -> Self::G { MultiResult(self.map(IntoWidget::into_widget).collect()) }
}

impl<E: 'static> ExprWidget<E> {
  pub fn into_widget<R, M: ?Sized>(self) -> Widget
  where
    E: FnMut() -> SingleResult<R>,
    R: IntoWidget<M>,
  {
    let Self { mut expr, upstream } = self;
    let expr = Box::new(move || expr().into_dyn_result());
    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget { expr, upstream })),
      children: Children::None,
    }
  }
}

impl<E: FnMut() -> MultiResult + 'static> ExprWidget<E> {
  #[inline]
  pub fn into_multi_child(self) -> Widget {
    let Self { mut expr, upstream } = self;
    let expr: Box<dyn FnMut() -> ExprResult> = Box::new(move || expr().into_dyn_result());

    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget { expr, upstream })),
      children: Children::None,
    }
  }
}

impl<R: SingleChild, E> SingleChild for ExprWidget<E> where E: FnMut() -> SingleResult<R> {}
impl<R: MultiChild, E> MultiChild for ExprWidget<E> where E: FnMut() -> SingleResult<R> {}

impl<C: SingleChild> SingleChild for ConstExprWidget<Option<C>> {}
impl<C: SingleChild> SingleChild for ConstExprWidget<C> {}
impl<C: MultiChild> MultiChild for ConstExprWidget<C> {}
impl<C: ComposeSingleChild> ComposeSingleChild for ConstExprWidget<C> {
  fn compose_single_child(this: StateWidget<Self>, child: Widget, ctx: &mut BuildCtx) -> Widget {
    match this {
      StateWidget::Stateless(c) => {
        ComposeSingleChild::compose_single_child(c.expr.into(), child, ctx)
      }
      StateWidget::Stateful(_) => unreachable!("ExprWidget should not be stateful."),
    }
  }
}
impl<C: ComposeMultiChild> ComposeMultiChild for ConstExprWidget<C> {
  fn compose_multi_child(
    this: StateWidget<Self>,
    children: Vec<Widget>,
    ctx: &mut BuildCtx,
  ) -> Widget {
    match this {
      StateWidget::Stateless(c) => {
        ComposeMultiChild::compose_multi_child(c.expr.into(), children, ctx)
      }
      StateWidget::Stateful(_) => unreachable!("ExprWidget should not be stateful."),
    }
  }
}

impl<W: Render + 'static> Render for ConstExprWidget<W> {
  #[inline]
  fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size {
    self.expr.perform_layout(clamp, ctx)
  }

  #[inline]
  fn only_sized_by_parent(&self) -> bool { self.expr.only_sized_by_parent() }

  #[inline]
  fn paint(&self, ctx: &mut PaintingCtx) { self.expr.paint(ctx) }
}

impl<W: Compose> Compose for ConstExprWidget<W> {
  fn compose(this: StateWidget<Self>, ctx: &mut BuildCtx) -> Widget {
    let w = match this {
      StateWidget::Stateless(s) => StateWidget::Stateless(s.expr),
      StateWidget::Stateful(_) => unreachable!(),
    };
    Compose::compose(w, ctx)
  }
}

impl IntoWidget<Widget> for ConstExprWidget<Widget> {
  #[inline]
  fn into_widget(self) -> Widget { self.expr }
}
impl<W: Query> Query for ConstExprWidget<W> {
  impl_proxy_query!(expr);
}

impl Generator {
  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }

  pub fn refresh(&mut self, tree: &mut WidgetTree) {
    let gen_result = &mut self.info.gen_dyn_widgets;
    let new_gen = (self.expr)();

    match (gen_result, new_gen) {
      (&mut DynamicWidgetInfo::SingleDynWithChild { gen_root, depth }, ExprResult::Single(w)) => {
        self.refresh_single_with_child(gen_root, w, depth, tree);
      }
      (DynamicWidgetInfo::WholeSubtree(ref old_widgets), result) => {
        let new_widgets = match result {
          ExprResult::Single(w) => {
            let w = w.unwrap_or_else(|| Void.into_widget());
            tree.replace_children(old_widgets, vec![w])
          }
          ExprResult::Multi(m) => tree.replace_children(old_widgets, m),
        };

        new_widgets.iter().for_each(|n| tree.mark_dirty(*n));
        self.info.gen_dyn_widgets = DynamicWidgetInfo::WholeSubtree(new_widgets);
      }
      _ => unreachable!("generator not match its generate"),
    }
  }

  fn refresh_single_with_child(
    &mut self,
    mut old_gen_root: WidgetId,
    widget: Option<Widget>,
    depth: usize,
    tree: &mut WidgetTree,
  ) {
    let mut new_gen_root = widget
      .and_then(|w| w.into_subtree(self.info().parent, tree))
      // gen root at least have a void widget as road sign.
      .unwrap_or_else(|| tree.empty_node());

    let declare_child_parent = single_down(old_gen_root, tree, depth as isize - 1);
    let (new_leaf, down_level) = down_to_leaf(new_gen_root, tree);
    let new_depth = down_level + 1;
    if let Some(declare_child_parent) = declare_child_parent {
      let (tree1, tree2) = unsafe { tree.split_tree() };
      declare_child_parent
        .children(tree1)
        .for_each(|c| new_leaf.append(c, tree2));
    }

    let mut old = Some(old_gen_root);
    let mut new = Some(new_gen_root);
    let mut replace_depth = 0;
    loop {
      if replace_depth >= depth {
        break;
      }
      let (o, n) = match (old, new) {
        (Some(o), Some(n)) => (o, n),
        _ => break,
      };

      // not same key
      if n
        .key(tree)
        .map_or(true, |new_key| Some(new_key) != o.key(tree))
      {
        break;
      }

      tree.swap_node_data(o, n);
      o.swap(n, tree);

      old = o.single_child(tree);
      new = n.single_child(tree);
      replace_depth += 1;
    }

    if replace_depth > 0 {
      std::mem::swap(&mut old_gen_root, &mut new_gen_root);
    } else {
      old_gen_root.insert_after(new_gen_root, tree);
    }

    let root = tree.root();
    old_gen_root.remove_subtree(tree);

    if let Some(new_from) = single_on_mounted(new_gen_root, replace_depth, false, tree) {
      single_on_mounted(new_from, new_depth - replace_depth, true, tree);
    }
    if old_gen_root == root {
      tree.set_root_id(new_gen_root);
    }

    self.info.gen_dyn_widgets = DynamicWidgetInfo::SingleDynWithChild {
      gen_root: new_gen_root,
      depth: new_depth,
    };
    tree.mark_dirty(new_gen_root);
  }
}

fn single_down(id: WidgetId, tree: &WidgetTree, mut down_level: isize) -> Option<WidgetId> {
  let mut res = Some(id);
  while down_level > 0 {
    down_level -= 1;
    res = res.unwrap().single_child(tree);
  }
  res
}

fn down_to_leaf(id: WidgetId, tree: &WidgetTree) -> (WidgetId, usize) {
  let mut leaf = id;
  let mut depth = 0;
  while let Some(c) = leaf.single_child(tree) {
    leaf = c;
    depth += 1;
  }
  (leaf, depth)
}

fn single_on_mounted(
  from: WidgetId,
  mut level: usize,
  brand_new: bool,
  tree: &mut WidgetTree,
) -> Option<WidgetId> {
  let mut next = Some(from);
  while level > 0 {
    let c = next.unwrap();
    c.on_mounted(tree, brand_new);
    next = c.single_child(tree);

    level -= 1;
  }
  next
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}

impl<W> SingleResult<W> {
  #[inline]
  fn into_dyn_result<M: ?Sized>(self) -> ExprResult
  where
    W: IntoWidget<M>,
  {
    ExprResult::Single(self.0.map(IntoWidget::into_widget))
  }
}

impl MultiResult {
  #[inline]
  fn into_dyn_result(self) -> ExprResult { ExprResult::Multi(self.0) }
}

#[cfg(test)]
mod tests {
  use crate::prelude::*;
  use crate::widget::{widget_tree::WidgetTree, IntoStateful};

  #[test]
  fn expr_widget_as_root() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      ExprWidget {
        expr: SizedBox { size: size.clone() },
        Void {}
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 2);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 2);

    assert_eq!(ids[1], new_ids[1]);
  }

  #[test]
  fn expr_widget_with_declare_child() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      SizedBox {
        size: Size::zero(),
        ExprWidget {
          expr: SizedBox { size: size.clone() },
          Void {}
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 3);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 3);

    assert_eq!(ids[0], new_ids[0]);
    assert_eq!(ids[2], new_ids[2]);
  }

  #[test]
  fn key_track() {
    let trigger = true.into_stateful();
    let w = widget! {
      track { trigger: trigger.clone() }
      ExprWidget {
        expr: trigger.then(||{
          widget!{
            Row {
              key: 4,
              Void { key: 1 }
              Void { key: 2 }
              Void { key: 3 }
              Row {
                Void { key: 1 }
                Void { key: 2 }
                Void { key: 3 }
              }
            }
          }
        }),
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 8);
    {
      *trigger.state_ref() = true;
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 8);
    // the subtree of inner row will not be tracked.
    assert_eq!(ids[0..4], new_ids[0..4]);
    assert_ne!(ids[4], new_ids[4]);
  }
}
