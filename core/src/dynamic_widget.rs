use std::{cell::RefCell, rc::Rc};

use crate::{impl_proxy_render, prelude::*, widget_tree::WidgetTree};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::{smallvec, SmallVec};

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<E> {
  pub(crate) expr: E,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared `ExprWidget` if its expression
/// not depends anything. And will stripe to its inner value when declare build.
pub struct ConstExprWidget<E>(E);

/// Generator is a virtual child construct from `ExprWidget` in a widget tree,
/// which use to generate dynamic widgets and provide ability to keep them up to
/// date in their lifetime.

#[derive(Clone)]
pub(crate) struct Generator(Rc<RefCell<InnerGenerator>>);

/// the information of a widget generated by `ExprWidget`.
pub(crate) enum DynamicWidgetInfo {
  /// ExprWidget generate single result,  and have static children. The depth
  /// describe the count from first dynamic widget to the static child.
  SingleDynWithChild { first: WidgetId, depth: usize },
  /// `ExprWidget` without static children, and the whole subtree of generated
  /// widget are dynamic widgets.
  WholeSubtree(SmallVec<[WidgetId; 1]>),
}

struct InnerGenerator {
  self_render: Box<dyn Render>,
  is_dirty: bool,
  gen_dyn_widgets: DynamicWidgetInfo,
  expr: Box<dyn FnMut(&mut BuildCtx) -> Vec<Widget>>,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl Generator {
  pub(crate) fn new_generator(
    expr: ExprWidget<Box<dyn for<'r> FnMut(&'r mut BuildCtx) -> Vec<Widget>>>,
    has_child: bool,
    tree: &mut WidgetTree,
  ) -> WidgetId {
    let ExprWidget { expr, upstream } = expr;
    let id = tree.empty_node();
    let gen_dyn_widgets = if has_child {
      DynamicWidgetInfo::SingleDynWithChild { first: id, depth: 1 }
    } else {
      DynamicWidgetInfo::WholeSubtree(smallvec![id])
    };

    let needs_regen = tree.needs_regen.clone();
    needs_regen.borrow_mut().insert(id);
    let generator = InnerGenerator {
      self_render: Box::new(Void),
      is_dirty: true,
      gen_dyn_widgets,
      expr,
    };
    let generator = Rc::new(RefCell::new(generator));
    let c_g = generator.clone();
    upstream
      .filter(|scope| scope.contains(ChangeScope::FRAMEWORK))
      .subscribe(move |_| {
        let mut c_info = c_g.borrow_mut();
        c_info.is_dirty = true;
        needs_regen
          .borrow_mut()
          .insert(c_info.gen_dyn_widgets.first());
      });

    *id.assert_get_mut(tree) = Box::new(Generator(generator));
    id
  }
}

impl Query for Generator {
  fn query_all(
    &self,
    type_id: TypeId,
    callback: &mut dyn FnMut(&dyn Any) -> bool,
    order: QueryOrder,
  ) {
    let mut continue_query = true;
    match order {
      QueryOrder::InnerFirst => {
        self.0.borrow().self_render.query_all(
          type_id,
          &mut |t| {
            continue_query = callback(t);
            continue_query
          },
          order,
        );
        if continue_query {
          if let Some(a) = self.query_filter(type_id) {
            callback(a);
          }
        }
      }
      QueryOrder::OutsideFirst => {
        if let Some(a) = self.query_filter(type_id) {
          if !callback(a) {
            return;
          }
        }
        if continue_query {
          self
            .0
            .borrow()
            .self_render
            .query_all(type_id, callback, order);
        }
      }
    }
  }
}

impl Render for Generator {
  impl_proxy_render!(0.borrow_mut().self_render);
}

// mark the expr of `ExprWidget` only generate at most one widget.
impl<E> ExprWidget<E> {
  /// Only if `ExprWidget` generate at most one widget can as a normal widget,
  /// otherwise it must been children of multi child widget.
  #[inline]
  pub fn into_widget<M: ?Sized, R>(self) -> Widget
  where
    E: FnMut(&mut BuildCtx) -> R + 'static,
    R: IntoChild<M, Option<Widget>>,
  {
    self.replace_expr_as_widget(|mut expr| move |ctx| expr(ctx).into_child().into_iter().collect())
  }

  fn replace_expr_as_widget<F, R2>(self, mut f: F) -> Widget
  where
    F: FnMut(E) -> R2,
    R2: FnMut(&mut BuildCtx) -> Vec<Widget> + 'static,
  {
    let Self { expr, upstream } = self;
    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget {
        expr: Box::new(f(expr)),
        upstream,
      })),
      children: Children::None,
    }
  }
}

impl<E, R> ExprWidget<E>
where
  E: FnMut(&mut BuildCtx) -> R + 'static,
{
  #[inline]
  pub(crate) fn inner_into_widget<M: ?Sized>(self) -> Widget
  where
    R: IntoChild<M, Vec<Widget>>,
  {
    self.replace_expr_as_widget(|mut expr| move |ctx| expr(ctx).into_child())
  }
}

pub struct ConstExprWidgetBuilder<E>(Option<E>);

impl<E> Declare for ConstExprWidget<E> {
  type Builder = ConstExprWidgetBuilder<E>;

  fn builder() -> Self::Builder { ConstExprWidgetBuilder(None) }
}

impl<E> ConstExprWidgetBuilder<E> {
  #[inline]
  pub fn expr(mut self, expr: E) -> Self {
    self.0 = Some(expr);
    self
  }

  pub fn build(self, _: &mut BuildCtx) -> E { self.0.expect("ConstExprWidget miss `expr` field.") }
}

impl WidgetTree {
  pub fn refresh_generator(&mut self, generator: WidgetId) {
    let mut sign = None;
    let generator_node = generator.replace_data(Box::new(Void), self);
    generator_node.query_all_type(
      |g: &Generator| {
        let mut g = g.0.borrow_mut();
        g.regenerate(self, sign);
        if sign.is_none() {
          sign = Some(g.gen_dyn_widgets.first());
        }
        true
      },
      QueryOrder::OutsideFirst,
    );
    generator.replace_data(generator_node, self);
  }
}

impl InnerGenerator {
  /// regenerate widgets, and keep the new generate widgets place start at
  /// `sign`, if sign is none, use the first widget of last generated at the
  /// sign.
  ///
  /// The sign is necessary, when generator generate an other generator, the
  /// should have same widget at their sign, but the inner one not know itself
  /// is a directly child of a generator, so it will have wrong sign, depends
  /// outside pass a correct one to it.
  fn regenerate(&mut self, tree: &mut WidgetTree, sign: Option<WidgetId>) {
    if !self.is_dirty {
      return;
    }
    self.is_dirty = false;

    let sign = sign.unwrap_or_else(|| self.gen_dyn_widgets.first());

    let current_theme = sign
      .parent(tree)
      .and_then(|s| {
        s.ancestors(tree).find_map(|id| {
          let mut theme = None;
          id.assert_get(tree)
            .query_on_first_type(QueryOrder::InnerFirst, |t: &Rc<Theme>| {
              theme = Some(t.clone());
            });
          theme
        })
      })
      .unwrap_or_else(|| tree.app_ctx().app_theme.clone());

    let mut ctx = BuildCtx::new(current_theme.clone(), tree);
    let mut new_gen = (self.expr)(&mut ctx);

    // Place the real render node in tree, effect lifecycle.
    std::mem::swap(&mut self.self_render, sign.assert_get_mut(tree));
    match &mut self.gen_dyn_widgets {
      DynamicWidgetInfo::SingleDynWithChild { depth, first } => {
        *first = sign;
        assert!(new_gen.len() <= 1);
        let w = new_gen.pop();
        *depth = refresh_single_with_child(sign, w, *depth, tree, current_theme)
      }
      DynamicWidgetInfo::WholeSubtree(gen_widgets) => {
        gen_widgets[0] = sign;
        refresh_multi(gen_widgets, new_gen, tree, current_theme)
      }
    };

    self.self_render = sign.replace_data(Box::new(Void), tree);
  }
}

fn refresh_single_with_child(
  sign: WidgetId,
  widget: Option<Widget>,
  depth: usize,
  tree: &mut WidgetTree,
  current_theme: Rc<Theme>,
) -> usize {
  let p = sign.parent(tree);
  let new_gen_root = widget
    .and_then(|w| w.into_subtree(p, tree, current_theme))
    // gen root at least have a void widget as road sign.
    .unwrap_or_else(|| tree.empty_node());

  let declare_child_parent = single_down(sign, tree, depth as isize - 1);
  let (new_leaf, down_level) = down_to_leaf(new_gen_root, tree);
  let new_depth = down_level + 1;
  if let Some(declare_child_parent) = declare_child_parent {
    // Safety: control two subtree not intersect.
    let (tree1, tree2) = unsafe { tree.split_tree() };
    declare_child_parent
      .children(tree1)
      .for_each(|c| new_leaf.append(c, tree2));
  }
  sign.insert_after(new_gen_root, tree);

  // we always keep the first dyn widget not change for `Generator`.
  sign.swap_data(new_gen_root, tree);
  sign.swap(new_gen_root, tree);
  // new is swap to old gen root.
  new_gen_root.remove_subtree(tree);
  single_on_mounted(sign, new_depth, true, tree);

  tree.mark_dirty(new_gen_root);
  depth
}

fn refresh_multi(
  gen_widgets: &mut SmallVec<[WidgetId; 1]>,
  widgets: Vec<Widget>,
  tree: &mut WidgetTree,
  current_theme: Rc<Theme>,
) {
  let tmp = tree.empty_node();
  let sign = gen_widgets[0];
  sign.insert_before(tmp, tree);
  tmp.swap(sign, tree);
  tmp.swap_data(sign, tree);
  gen_widgets[0] = tmp;

  let parent = sign.parent(tree);
  gen_widgets.iter().for_each(|w| w.remove_subtree(tree));
  gen_widgets.clear();

  let mut cursor = sign;
  for w in widgets {
    if let Some(n) = w.into_subtree(parent, tree, current_theme.clone()) {
      cursor.insert_after(n, tree);
      gen_widgets.push(n);
      cursor = n;
    }
  }

  if gen_widgets.is_empty() {
    gen_widgets.push(sign)
  } else {
    let first = gen_widgets[0];
    first.swap(sign, tree);
    first.swap_data(sign, tree);
    first.remove_subtree(tree);
    gen_widgets[0] = sign;

    gen_widgets.iter().for_each(|n| {
      n.on_mounted_subtree(tree, true);
      tree.mark_dirty(*n)
    });
  }
}

impl DynamicWidgetInfo {
  fn first(&self) -> WidgetId {
    match self {
      DynamicWidgetInfo::SingleDynWithChild { first, .. } => *first,
      DynamicWidgetInfo::WholeSubtree(d) => {
        *d.first().expect("dynamic must have at least one child.")
      }
    }
  }
}

fn single_down(id: WidgetId, tree: &WidgetTree, mut down_level: isize) -> Option<WidgetId> {
  let mut res = Some(id);
  while down_level > 0 {
    down_level -= 1;
    res = res.unwrap().single_child(tree);
  }
  res
}

fn down_to_leaf(id: WidgetId, tree: &WidgetTree) -> (WidgetId, usize) {
  let mut leaf = id;
  let mut depth = 0;
  while let Some(c) = leaf.single_child(tree) {
    leaf = c;
    depth += 1;
  }
  (leaf, depth)
}

fn single_on_mounted(
  from: WidgetId,
  mut level: usize,
  brand_new: bool,
  tree: &mut WidgetTree,
) -> Option<WidgetId> {
  let mut next = Some(from);
  while level > 0 {
    let c = next.unwrap();
    c.on_mounted(tree, brand_new);
    next = c.single_child(tree);

    level -= 1;
  }
  next
}

#[cfg(test)]
mod tests {
  use crate::{prelude::*, test::*, widget_tree::WidgetTree};

  #[test]
  fn expr_widget_as_root() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      ExprWidget {
        expr: MockBox { size: size.clone() },
        Void {}
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 2);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 2);

    assert_eq!(ids[1], new_ids[1]);
  }

  #[test]
  fn expr_widget_with_declare_child() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      MockBox {
        size: Size::zero(),
        ExprWidget {
          expr: MockBox { size: size.clone() },
          Void {}
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 3);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 3);

    assert_eq!(ids[0], new_ids[0]);
    assert_eq!(ids[2], new_ids[2]);
  }
}
