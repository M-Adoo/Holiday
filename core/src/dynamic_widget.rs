use std::{cell::RefCell, collections::HashMap, rc::Rc};

use crate::{impl_proxy_render, prelude::*, widget_tree::WidgetTree};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::{smallvec, SmallVec};

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<E> {
  pub(crate) expr: E,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared `ExprWidget` if its expression
/// not depends anything. And will stripe to its inner value when declare build.
pub struct ConstExprWidget<E>(E);

/// Generator is a virtual child construct from `ExprWidget` in a widget tree,
/// which use to generate dynamic widgets and provide ability to keep them up to
/// date in their lifetime.

#[derive(Clone)]
pub(crate) struct Generator(Rc<RefCell<InnerGenerator>>);

/// the information of a widget generated by `ExprWidget`.
pub(crate) enum DynamicWidgetInfo {
  /// ExprWidget generate single result,  and have static children. The depth
  /// describe the count from first dynamic widget to the static child.
  SingleDynWithChild { first: WidgetId, depth: usize },
  /// `ExprWidget` without static children, and the whole subtree of generated
  /// widget are dynamic widgets.
  WholeSubtree(SmallVec<[WidgetId; 1]>),
}

struct InnerGenerator {
  self_render: Box<dyn Render>,
  is_dirty: bool,
  gen_dyn_widgets: DynamicWidgetInfo,
  expr: Box<dyn FnMut(&mut BuildCtx) -> Vec<Widget>>,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl Generator {
  pub(crate) fn new_generator(
    expr: BoxedExprWidget,
    has_child: bool,
    tree: &mut WidgetTree,
  ) -> WidgetId {
    let ExprWidget { expr, upstream } = expr;
    let id = tree.empty_node();
    let gen_dyn_widgets = if has_child {
      DynamicWidgetInfo::SingleDynWithChild { first: id, depth: 1 }
    } else {
      DynamicWidgetInfo::WholeSubtree(smallvec![id])
    };

    let needs_regen = tree.needs_regen.clone();
    needs_regen.borrow_mut().insert(id);
    let generator = InnerGenerator {
      self_render: Box::new(Void),
      is_dirty: true,
      gen_dyn_widgets,
      expr,
    };
    let generator = Rc::new(RefCell::new(generator));
    let c_g = generator.clone();
    upstream
      .filter(|scope| scope.contains(ChangeScope::FRAMEWORK))
      .subscribe(move |_| {
        let mut c_info = c_g.borrow_mut();
        c_info.is_dirty = true;
        needs_regen
          .borrow_mut()
          .insert(c_info.gen_dyn_widgets.first());
      });

    *id.assert_get_mut(tree) = Box::new(Generator(generator));
    id
  }
}

impl Query for Generator {
  fn query_all(
    &self,
    type_id: TypeId,
    callback: &mut dyn FnMut(&dyn Any) -> bool,
    order: QueryOrder,
  ) {
    let mut continue_query = true;
    match order {
      QueryOrder::InnerFirst => {
        self.0.borrow().self_render.query_all(
          type_id,
          &mut |t| {
            continue_query = callback(t);
            continue_query
          },
          order,
        );
        if continue_query {
          if let Some(a) = self.query_filter(type_id) {
            callback(a);
          }
        }
      }
      QueryOrder::OutsideFirst => {
        if let Some(a) = self.query_filter(type_id) {
          if !callback(a) {
            return;
          }
        }
        if continue_query {
          self
            .0
            .borrow()
            .self_render
            .query_all(type_id, callback, order);
        }
      }
    }
  }
}

impl Render for Generator {
  impl_proxy_render!(0.borrow_mut().self_render);
}

// mark the expr of `ExprWidget` only generate at most one widget.
impl<E> ExprWidget<E> {
  /// Only if `ExprWidget` generate at most one widget can as a normal widget,
  /// otherwise it must been children of multi child widget.
  #[inline]
  pub fn into_widget<M: ?Sized, R>(self) -> Widget
  where
    E: FnMut(&mut BuildCtx) -> R + 'static,
    R: IntoChild<M, Option<Widget>>,
  {
    self.replace_expr_as_widget(|mut expr| move |ctx| expr(ctx).into_child().into_iter().collect())
  }

  fn replace_expr_as_widget<F, R2>(self, mut f: F) -> Widget
  where
    F: FnMut(E) -> R2,
    R2: FnMut(&mut BuildCtx) -> Vec<Widget> + 'static,
  {
    let Self { expr, upstream } = self;
    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget {
        expr: Box::new(f(expr)),
        upstream,
      })),
      children: <_>::default(),
    }
  }
}

impl<E, R> ExprWidget<E>
where
  E: FnMut(&mut BuildCtx) -> R + 'static,
{
  #[inline]
  pub(crate) fn inner_into_widget<M: ?Sized>(self) -> Widget
  where
    R: IntoChild<M, ChildVec<Widget>>,
  {
    self.replace_expr_as_widget(|mut expr| move |ctx| expr(ctx).into_child().into_inner())
  }
}

pub struct ConstExprWidgetBuilder<E>(Option<E>);

impl<E> Declare for ConstExprWidget<E> {
  type Builder = ConstExprWidgetBuilder<E>;

  fn builder() -> Self::Builder { ConstExprWidgetBuilder(None) }
}

impl<E> ConstExprWidgetBuilder<E> {
  #[inline]
  pub fn expr(mut self, expr: E) -> Self {
    self.0 = Some(expr);
    self
  }

  pub fn build(self, _: &mut BuildCtx) -> E { self.0.expect("ConstExprWidget miss `expr` field.") }
}

impl WidgetTree {
  pub fn refresh_generator(&mut self, generator: WidgetId) {
    let mut sign = None;
    let generator_node = generator.replace_data(Box::new(Void), self);
    generator_node.query_all_type(
      |g: &Generator| {
        let mut g = g.0.borrow_mut();
        g.regenerate(self, sign);
        if sign.is_none() {
          sign = Some(g.gen_dyn_widgets.first());
        }
        true
      },
      QueryOrder::OutsideFirst,
    );
    generator.replace_data(generator_node, self);
  }
}

impl InnerGenerator {
  /// regenerate widgets, and keep the new generate widgets place start at
  /// `sign`, if sign is none, use the first widget of last generated at the
  /// sign.
  ///
  /// The sign is necessary, when generator generate an other generator, the
  /// should have same widget at their sign, but the inner one not know itself
  /// is a directly child of a generator, so it will have wrong sign, depends
  /// outside pass a correct one to it.
  fn regenerate(&mut self, tree: &mut WidgetTree, sign: Option<WidgetId>) {
    if !self.is_dirty {
      return;
    }
    self.is_dirty = false;

    let sign = sign.unwrap_or_else(|| self.gen_dyn_widgets.first());

    let current_theme = sign
      .parent(tree)
      .and_then(|s| {
        s.ancestors(tree).find_map(|id| {
          let mut theme = None;
          id.assert_get(tree)
            .query_on_first_type(QueryOrder::InnerFirst, |t: &Rc<Theme>| {
              theme = Some(t.clone());
            });
          theme
        })
      })
      .unwrap_or_else(|| tree.app_ctx().app_theme.clone());

    let mut ctx = BuildCtx::new(current_theme.clone(), tree);
    let mut new_gen = (self.expr)(&mut ctx);

    // Place the real render node in tree, effect lifecycle.
    std::mem::swap(&mut self.self_render, sign.assert_get_mut(tree));
    match &mut self.gen_dyn_widgets {
      DynamicWidgetInfo::SingleDynWithChild { depth, first } => {
        *first = sign;
        assert!(new_gen.len() <= 1);
        let w = new_gen.pop();
        *depth = refresh_single_with_child(sign, w, *depth, tree, current_theme)
      }
      DynamicWidgetInfo::WholeSubtree(gen_widgets) => {
        gen_widgets[0] = sign;
        refresh_multi(gen_widgets, new_gen, tree, current_theme)
      }
    };

    self.self_render = sign.replace_data(Box::new(Void), tree);
  }
}

fn refresh_single_with_child(
  sign: WidgetId,
  widget: Option<Widget>,
  depth: usize,
  tree: &mut WidgetTree,
  current_theme: Rc<Theme>,
) -> usize {
  let p = sign.parent(tree);
  let new_gen_root = widget
    .and_then(|w| w.into_subtree(p, tree, current_theme))
    // gen root at least have a void widget as road sign.
    .unwrap_or_else(|| tree.empty_node());

  let declare_child_parent = single_down(sign, tree, depth as isize - 1);
  let (new_leaf, down_level) = down_to_leaf(new_gen_root, tree);
  let new_depth = down_level + 1;
  if let Some(declare_child_parent) = declare_child_parent {
    // Safety: control two subtree not intersect.
    let (tree1, tree2) = unsafe { tree.split_tree() };
    declare_child_parent
      .children(tree1)
      .for_each(|c| new_leaf.append(c, tree2));
  }
  sign.insert_after(new_gen_root, tree);

  // we always keep the first dyn widget not change for `Generator`.
  sign.swap_data(new_gen_root, tree);
  sign.swap_children(new_gen_root, tree);
  // new is swap to old gen root.

  let old_to_news = collect_refreshed_widgets(
    &SmallVec::from_elem(new_gen_root, 1),
    &SmallVec::from_elem(sign, 1),
    tree,
  );

  new_gen_root.remove_subtree(tree, &old_to_news);
  single_on_mounted(sign, new_depth, tree, &old_to_news);

  tree.mark_dirty(new_gen_root);
  depth
}

pub(crate) fn collect_refreshed_widgets(
  olds: &SmallVec<[WidgetId; 1]>,
  news: &SmallVec<[WidgetId; 1]>,
  tree: &mut WidgetTree,
) -> HashMap<WidgetId, WidgetId> {
  let mut old_to_news: HashMap<WidgetId, WidgetId> = HashMap::default();

  let mut old_keys: HashMap<Key, WidgetId> = HashMap::default();
  olds.iter().for_each(|id| {
    id.key(tree).map(|key| {
      old_keys.insert(key, *id);
    });
  });

  news
    .iter()
    .flat_map(|id| {
      id.key(tree)
        .and_then(|key| old_keys.get(&key))
        .zip(Some(id))
    })
    .for_each(|(old, new)| {
      old_to_news.insert(*old, *new);
    });

  old_to_news
}

fn refresh_multi(
  gen_widgets: &mut SmallVec<[WidgetId; 1]>,
  widgets: Vec<Widget>,
  tree: &mut WidgetTree,
  current_theme: Rc<Theme>,
) {
  let tmp = tree.empty_node();
  let sign = gen_widgets[0];
  sign.insert_before(tmp, tree);
  tmp.swap_children(sign, tree);
  tmp.swap_data(sign, tree);
  gen_widgets[0] = tmp;

  let parent = sign.parent(tree);
  let olds = gen_widgets.clone();
  gen_widgets.clear();

  let mut cursor = sign;
  for w in widgets {
    if let Some(n) = w.into_subtree(parent, tree, current_theme.clone()) {
      cursor.insert_after(n, tree);
      gen_widgets.push(n);
      cursor = n;
    }
  }

  if gen_widgets.is_empty() {
    gen_widgets.push(sign)
  } else {
    let first = gen_widgets[0];
    first.swap_children(sign, tree);
    first.swap_data(sign, tree);
    first.remove_subtree(tree, &HashMap::default());
    gen_widgets[0] = sign;
  }

  let old_to_news = collect_refreshed_widgets(&olds, &gen_widgets, tree);
  olds.iter().for_each(|w| {
    w.remove_subtree(tree, &old_to_news);
  });
  gen_widgets.iter().for_each(|n| {
    n.on_mounted_subtree(tree, &old_to_news);
    tree.mark_dirty(*n)
  });
}

impl DynamicWidgetInfo {
  fn first(&self) -> WidgetId {
    match self {
      DynamicWidgetInfo::SingleDynWithChild { first, .. } => *first,
      DynamicWidgetInfo::WholeSubtree(d) => {
        *d.first().expect("dynamic must have at least one child.")
      }
    }
  }
}

fn single_down(id: WidgetId, tree: &WidgetTree, mut down_level: isize) -> Option<WidgetId> {
  let mut res = Some(id);
  while down_level > 0 {
    down_level -= 1;
    res = res.unwrap().single_child(tree);
  }
  res
}

fn down_to_leaf(id: WidgetId, tree: &WidgetTree) -> (WidgetId, usize) {
  let mut leaf = id;
  let mut depth = 0;
  while let Some(c) = leaf.single_child(tree) {
    leaf = c;
    depth += 1;
  }
  (leaf, depth)
}

fn single_on_mounted(
  from: WidgetId,
  mut level: usize,
  tree: &mut WidgetTree,
  old_to_news: &HashMap<WidgetId, WidgetId>,
) -> Option<WidgetId> {
  let mut next = Some(from);

  let new_to_olds = old_to_news
    .iter()
    .map(|(old, new)| (*new, *old))
    .collect::<HashMap<WidgetId, WidgetId>>();
  while level > 0 {
    let c = next.unwrap();
    let mount = new_to_olds
      .get(&c)
      .map_or(MountedType::New, |id| MountedType::Replace(*id));
    c.on_mounted(tree, mount);
    next = c.single_child(tree);

    level -= 1;
  }
  next
}

#[cfg(test)]
mod tests {
  use crate::{prelude::*, test::*, widget_tree::WidgetTree};
  use std::cell::RefCell;
  use std::rc::Rc;

  #[test]
  fn expr_widget_as_root() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      ExprWidget {
        expr: MockBox { size: size.clone() },
        Void {}
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 2);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 2);

    assert_eq!(ids[1], new_ids[1]);
  }

  #[test]
  fn expr_widget_with_declare_child() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      MockBox {
        size: Size::zero(),
        ExprWidget {
          expr: MockBox { size: size.clone() },
          Void {}
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 3);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 3);

    assert_eq!(ids[0], new_ids[0]);
    assert_eq!(ids[2], new_ids[2]);
  }
  #[test]
  fn expr_widget_mounted_new() {
    let v = vec![1, 2, 3].into_stateful();

    let new_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let refresh_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let drop_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let replaced_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let w = widget! {
      track { v: v.clone(),
              new_cnt: new_cnt.clone(),
              refresh_cnt: refresh_cnt.clone(),
              drop_cnt: drop_cnt.clone(),
              replaced_cnt: replaced_cnt.clone(), }

        ExprWidget {
          expr: widget! { MockMulti {
        ExprWidget {
          expr: {
            v.iter().map(move |_| {
              widget! {
                MockBox{
                  size: Size::zero(),
                  mounted: move |_, t| {
                    match t {
                      MountedType::New => *new_cnt.borrow_mut() += 1,
                      MountedType::Replace(_) => *refresh_cnt.borrow_mut() += 1,
                    };
                  },
                  disposed: move |_, t| {
                    match t {
                    DisposedType::Drop => *drop_cnt.borrow_mut() += 1,
                    DisposedType::Replaced(_) => *replaced_cnt.borrow_mut() += 1,
                    }

                  }
                }
              }
            }).collect::<Vec<_>>()
          }
        }
      }
      }}
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 3);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);
    assert_eq!(*drop_cnt.raw_ref().borrow(), 0);
    assert_eq!(*replaced_cnt.raw_ref().borrow(), 0);

    v.state_ref().push(4);
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 7);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);
    assert_eq!(*drop_cnt.raw_ref().borrow(), 3);
    assert_eq!(*replaced_cnt.raw_ref().borrow(), 0);

    v.state_ref().pop();
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 10);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);
    assert_eq!(*drop_cnt.raw_ref().borrow(), 7);
    assert_eq!(*replaced_cnt.raw_ref().borrow(), 0);
  }

  #[test]
  fn expr_widget_mounted_track() {
    let v = vec![1, 2, 3].into_stateful();
    let new_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let refresh_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let drop_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let replaced_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let w = widget! {
      track { v: v.clone(),
              new_cnt: new_cnt.clone(),
              refresh_cnt: refresh_cnt.clone(),
              drop_cnt: drop_cnt.clone(),
              replaced_cnt: replaced_cnt.clone() }
      MockMulti {
        ExprWidget {
          expr: {
            v.iter().enumerate().map(move |(idx, _)| {
            widget! {
              MockBox{
                key: idx,
                size: Size::zero(),
                mounted: move |_, t| {
                  match t {
                    MountedType::New => *new_cnt.borrow_mut() += 1,
                    MountedType::Replace(_) => *refresh_cnt.borrow_mut() += 1,
                  };
                },
                disposed: move |_, t| {
                  match t {
                    DisposedType::Drop => *drop_cnt.borrow_mut() += 1,
                    DisposedType::Replaced(_) => *replaced_cnt.borrow_mut() += 1,
                  };
                }
              }
            }
          }).collect::<Vec<_>>()
          }
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 3);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);
    assert_eq!(*replaced_cnt.raw_ref().borrow(), 0);
    assert_eq!(*drop_cnt.raw_ref().borrow(), 0);

    v.state_ref().push(4);
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 4);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 3);
    assert_eq!(*drop_cnt.raw_ref().borrow(), 0);
    assert_eq!(*replaced_cnt.raw_ref().borrow(), 3);

    v.state_ref().pop();
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 4);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 6);
    assert_eq!(*drop_cnt.raw_ref().borrow(), 1);
    assert_eq!(*replaced_cnt.raw_ref().borrow(), 6);
  }
}
