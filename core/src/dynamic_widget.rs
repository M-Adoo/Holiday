use std::collections::HashMap;

use crate::{
  impl_proxy_query,
  prelude::{key::Key, widget_tree::WidgetTree, *},
};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::SmallVec;

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<R> {
  #[declare(convert = box_trait(FnMut(&mut dyn FnMut(Widget)) -> R))]
  pub(crate) expr: Box<dyn FnMut(&mut dyn FnMut(Widget)) -> R>,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

pub struct GenMostOne;
pub struct GenMulti;

/// ConstExprWidget is convert from uer declared  `ExprWidget` which but its
/// expression not following anything.
#[derive(Declare)]
pub struct ConstExprWidget<W> {
  #[allow(unused)]
  pub(crate) expr: W,
}

/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut(&mut dyn FnMut(Widget))>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub(crate) struct GeneratorID(usize);

pub struct GeneratorInfo {
  id: GeneratorID,
  /// The parent of the generator.
  parent: Option<WidgetId>,
  /// widget generated by the generator.
  generated_widgets: SmallVec<[WidgetId; 1]>,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: Option<WidgetId>,
    generated_widgets: SmallVec<[WidgetId; 1]>,
  ) -> Self {
    GeneratorInfo { id, parent, generated_widgets }
  }

  pub(crate) fn parent(&self) -> Option<WidgetId> { self.parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.id }
}

pub trait IntoExprGen<M: ?Sized> {
  type G;
  fn into_expr_gen(self, cb: &mut dyn FnMut(Widget)) -> Self::G;
}

impl<W, M: ?Sized> IntoExprGen<(GenMostOne, &M)> for W
where
  W: IntoWidget<M>,
{
  type G = GenMostOne;
  #[inline]
  fn into_expr_gen(self, cb: &mut dyn FnMut(Widget)) -> Self::G {
    cb(self.into_widget());
    GenMostOne
  }
}

impl<W, M: ?Sized> IntoExprGen<(Option<GenMostOne>, &M)> for Option<W>
where
  W: IntoWidget<M>,
{
  type G = GenMostOne;
  #[inline]
  fn into_expr_gen(self, cb: &mut dyn FnMut(Widget)) -> Self::G {
    if let Some(w) = self {
      cb(w.into_widget());
    }
    GenMostOne
  }
}

impl<R, M: ?Sized> IntoExprGen<(GenMulti, &M)> for R
where
  R: Iterator,
  R::Item: IntoWidget<M>,
{
  type G = GenMulti;
  #[inline]
  fn into_expr_gen(self, cb: &mut dyn FnMut(Widget)) -> Self::G {
    self.for_each(|w| {
      cb(w.into_widget());
    });
    GenMulti
  }
}

// only implement `GenMoistOne`, `ExprWidget<GenMulti>` only valid as child of
// `SingleMultiWidget`.
impl ExprWidget<GenMostOne> {
  #[inline]
  pub fn into_widget(self) -> Widget {
    let Self { mut expr, upstream } = self;
    let new_expr = move |cb: &mut dyn FnMut(Widget)| {
      expr(&mut |w: Widget| {
        if matches!(w.0, WidgetInner::ExprGenMulti(_)) {
          panic!("`ExprWidget<GenMostOne>` generate `ExprWidget<GenMulti>` is not allowed.")
        }
        cb(w)
      })
    };

    Widget(WidgetInner::ExprGenOnce(ExprWidget {
      expr: Box::new(new_expr),
      upstream,
    }))
  }
}

impl<C: SingleChild> SingleChild for ConstExprWidget<Option<C>> {}
impl<C: SingleChild> SingleChild for ConstExprWidget<C> {}
impl<C: MultiChild> MultiChild for ConstExprWidget<C> {}
impl<C: ComposeSingleChild> ComposeSingleChild for ConstExprWidget<C> {
  fn compose_single_child(this: StateWidget<Self>, child: Widget, ctx: &mut BuildCtx) -> Widget {
    match this {
      StateWidget::Stateless(c) => {
        ComposeSingleChild::compose_single_child(c.expr.into(), child, ctx)
      }
      StateWidget::Stateful(_) => unreachable!("ExprWidget should not be stateful."),
    }
  }
}
impl<C: ComposeMultiChild> ComposeMultiChild for ConstExprWidget<C> {
  fn compose_multi_child(
    this: StateWidget<Self>,
    children: Vec<Widget>,
    ctx: &mut BuildCtx,
  ) -> Widget {
    match this {
      StateWidget::Stateless(c) => {
        ComposeMultiChild::compose_multi_child(c.expr.into(), children, ctx)
      }
      StateWidget::Stateful(_) => unreachable!("ExprWidget should not be stateful."),
    }
  }
}

impl<W: Render + 'static> Render for ConstExprWidget<W> {
  #[inline]
  fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size {
    self.expr.perform_layout(clamp, ctx)
  }

  #[inline]
  fn only_sized_by_parent(&self) -> bool { self.expr.only_sized_by_parent() }

  #[inline]
  fn paint(&self, ctx: &mut PaintingCtx) { self.expr.paint(ctx) }
}

impl<W: Compose> Compose for ConstExprWidget<W> {
  fn compose(this: StateWidget<Self>, ctx: &mut BuildCtx) -> Widget {
    let w = match this {
      StateWidget::Stateless(s) => StateWidget::Stateless(s.expr),
      StateWidget::Stateful(_) => unreachable!(),
    };
    Compose::compose(w, ctx)
  }
}

impl IntoWidget<Widget> for ConstExprWidget<Widget> {
  #[inline]
  fn into_widget(self) -> Widget { self.expr }
}
impl<W: Query> Query for ConstExprWidget<W> {
  impl_proxy_query!(expr);
}

impl Generator {
  #[inline]
  pub(crate) fn update_generated_widgets(&mut self, tree: &mut WidgetTree) {
    let Self { info, expr } = self;

    let mut cursor = GeneratorCursor::new(&info, tree);
    let mut key_widgets = info
      .generated_widgets
      .drain(..)
      .filter_map(|id| {
        let mut key = None;
        id.assert_get(tree)
          .query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
            key = Some(k.clone());
          });
        if let Some(key) = key {
          id.detach(tree);
          Some((key.clone(), id))
        } else {
          id.remove_subtree(tree);
          None
        }
      })
      .collect::<HashMap<_, _, ahash::RandomState>>();

    expr(&mut |c| {
      tree.insert_widget_to(info.parent, c, |node, tree| {
        let mut old = None;
        node.query_on_first_type(QueryOrder::OutsideFirst, |k: &Key| {
          old = key_widgets.remove(k);
        });

        let id = if let Some(id) = old {
          *id.assert_get_mut(tree) = node;
          id
        } else {
          tree.new_node(node)
        };

        cursor.add(id, tree);
        tree.mark_dirty(id);
        info.generated_widgets.push(id);
        if old.is_none() {
          id.on_mounted(tree);
        }
        id
      });
    });
    key_widgets
      .into_iter()
      .for_each(|(_, k)| k.remove_subtree(tree));

    if info.generated_widgets.is_empty() {
      // add void widget for generator, so we can always know where to replace dynamic
      // widget.
      let road_sign = tree.new_node(Box::new(Void));
      info.generated_widgets.push(road_sign);
      cursor.add(road_sign, tree);
    }
  }

  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}

enum GeneratorCursor {
  ParentFirstChild(WidgetId),
  SiblingOf(WidgetId),
  AsRoot,
  MultiRoot,
}

impl GeneratorCursor {
  fn new(info: &GeneratorInfo, tree: &WidgetTree) -> Self {
    if let Some(prev) = info
      .generated_widgets
      .first()
      .and_then(|l| l.prev_sibling(tree))
    {
      Self::SiblingOf(prev)
    } else if let Some(p) = info.parent() {
      Self::ParentFirstChild(p)
    } else {
      Self::AsRoot
    }
  }

  fn add(&mut self, id: WidgetId, tree: &mut WidgetTree) {
    match self {
      GeneratorCursor::ParentFirstChild(p) => {
        if let Some(s) = p.first_child(tree) {
          s.insert_before(id, tree);
        } else {
          p.append(id, tree);
        }
        *self = GeneratorCursor::SiblingOf(id)
      }
      GeneratorCursor::SiblingOf(sibling) => {
        sibling.insert_after(id, tree);
        *sibling = id;
      }
      GeneratorCursor::AsRoot => {
        tree.set_root(id);
        *self = GeneratorCursor::MultiRoot;
      }
      GeneratorCursor::MultiRoot => {
        panic!("ExprWidget as root, but generate more than once widget.")
      }
    }
  }
}
