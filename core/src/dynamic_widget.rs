use std::{cell::RefCell, collections::HashSet, rc::Rc};

use crate::{
  impl_proxy_render,
  prelude::{widget_tree::WidgetTree, *},
};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::{smallvec, SmallVec};

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<E> {
  pub(crate) expr: E,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared  `ExprWidget` which but its
/// expression not following anything.
#[derive(Declare)]
pub struct ConstExprWidget<W> {
  pub(crate) expr: W,
}

/// Generator is a virtual child construct from `ExprWidget` in a widget tree,
/// which use to generate dynamic widgets and provide ability to keep them up to
/// date in their lifetime.

#[derive(Clone)]
pub(crate) struct Generator(Rc<RefCell<InnerGenerator>>);

/// the information of a widget generated by `ExprWidget`.
pub(crate) enum DynamicWidgetInfo {
  /// ExprWidget generate single result,  and have static children. The depth
  /// describe the count from first dynamic widget to the static child.
  SingleDynWithChild { first: WidgetId, depth: usize },
  /// `ExprWidget` without static children, and the whole subtree of generated
  /// widget are dynamic widgets.
  WholeSubtree(SmallVec<[WidgetId; 1]>),
}

struct InnerGenerator {
  self_render: Box<dyn Render>,
  is_dirty: bool,
  gen_dyn_widgets: DynamicWidgetInfo,
  expr: Box<dyn FnMut(&mut BuildCtx) -> DynamicWidget>,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl Generator {
  pub(crate) fn new_generator(
    expr: ExprWidget<Box<dyn for<'r> FnMut(&'r mut BuildCtx) -> DynamicWidget>>,
    has_child: bool,
    tree: &mut WidgetTree,
  ) -> WidgetId {
    let ExprWidget { expr, upstream } = expr;
    let id = tree.empty_node();
    let gen_dyn_widgets = if has_child {
      DynamicWidgetInfo::SingleDynWithChild { first: id, depth: 1 }
    } else {
      DynamicWidgetInfo::WholeSubtree(smallvec![id])
    };

    let needs_regen = tree.needs_regen.clone();
    needs_regen.borrow_mut().insert(id);
    let generator = InnerGenerator {
      self_render: Box::new(Void),
      is_dirty: true,
      gen_dyn_widgets,
      expr,
    };
    let generator = Rc::new(RefCell::new(generator));
    let c_g = generator.clone();
    upstream
      .filter(|scope| scope.contains(ChangeScope::FRAMEWORK))
      .subscribe(move |_| {
        let mut c_info = c_g.borrow_mut();
        c_info.is_dirty = true;
        needs_regen
          .borrow_mut()
          .insert(c_info.gen_dyn_widgets.first());
      });

    *id.assert_get_mut(tree) = Box::new(Generator(generator));
    id
  }
}

impl Query for Generator {
  fn query_all(
    &self,
    type_id: TypeId,
    callback: &mut dyn FnMut(&dyn Any) -> bool,
    order: QueryOrder,
  ) {
    let mut continue_query = true;
    match order {
      QueryOrder::InnerFirst => {
        self.0.borrow().self_render.query_all(
          type_id,
          &mut |t| {
            continue_query = callback(t);
            continue_query
          },
          order,
        );
        if continue_query {
          if let Some(a) = self.query_filter(type_id) {
            callback(a);
          }
        }
      }
      QueryOrder::OutsideFirst => {
        if let Some(a) = self.query_filter(type_id) {
          if !callback(a) {
            return;
          }
        }
        if continue_query {
          self
            .0
            .borrow()
            .self_render
            .query_all(type_id, callback, order);
        }
      }
    }
  }
}

impl Render for Generator {
  impl_proxy_render!(0.borrow_mut().self_render);
}

pub enum DynamicWidget {
  Single(Option<Widget>),
  Multi(Box<dyn Iterator<Item = Widget>>),
}

pub trait IntoDynWidget<M: ?Sized> {
  fn into_dyn_widget(self) -> DynamicWidget;
}

// mark the expr of `ExprWidget` only generate at most one widget.
pub trait SingleDyn<M: ?Sized>: IntoDynWidget<M> {}

impl<W, M: ?Sized> IntoDynWidget<&M> for W
where
  W: IntoWidget<M>,
{
  #[inline]
  fn into_dyn_widget(self) -> DynamicWidget { DynamicWidget::Single(Some(self.into_widget())) }
}

impl<I, M> IntoDynWidget<dyn Iterator<Item = M>> for I
where
  M: ?Sized,
  I: IntoIterator + 'static,
  I::Item: IntoWidget<M>,
{
  #[inline]
  fn into_dyn_widget(self) -> DynamicWidget {
    DynamicWidget::Multi(Box::new(self.into_iter().map(|w| w.into_widget())))
  }
}

impl<W, M: ?Sized> SingleDyn<&M> for W where W: IntoWidget<M> {}
impl<W, M> SingleDyn<dyn Iterator<Item = M>> for Option<W>
where
  M: ?Sized,
  W: IntoWidget<M> + 'static,
{
}

impl<E> ExprWidget<E> {
  /// Only if `ExprWidget` generate at most one widget can as a normal widget,
  /// otherwise it must been children of multi child widget.
  #[inline]
  pub fn into_widget<M: ?Sized, R>(self) -> Widget
  where
    E: FnMut(&mut BuildCtx) -> R + 'static,
    R: SingleDyn<M>,
  {
    self.inner_into_widget()
  }
}

impl<E, R> ExprWidget<E>
where
  E: FnMut(&mut BuildCtx) -> R + 'static,
{
  pub(crate) fn inner_into_widget<M: ?Sized>(self) -> Widget
  where
    R: IntoDynWidget<M>,
  {
    let Self { mut expr, upstream } = self;

    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget {
        expr: Box::new(move |ctx| expr(ctx).into_dyn_widget()),
        upstream,
      })),
      children: Children::None,
    }
  }
}

impl<W> ConstExprWidget<W> {
  #[inline]
  pub fn into_widget<M: ?Sized>(self) -> Widget
  where
    W: IntoWidget<M>,
  {
    self.expr.into_widget()
  }
}

impl WidgetTree {
  pub fn refresh_generator(&mut self, generator: WidgetId) {
    let mut sign = None;
    let generator_node = generator.replace_data(Box::new(Void), self);
    generator_node.query_all_type(
      |g: &Generator| {
        let mut g = g.0.borrow_mut();
        g.regenerate(self, sign);
        if sign.is_none() {
          sign = Some(g.gen_dyn_widgets.first());
        }
        true
      },
      QueryOrder::OutsideFirst,
    );
    generator.replace_data(generator_node, self);
  }
}

impl InnerGenerator {
  /// regenerate widgets, and keep the new generate widgets place start at
  /// `sign`, if sign is none, use the first widget of last generated at the
  /// sign.
  ///
  /// The sign is necessary, when generator generate an other generator, the
  /// should have same widget at their sign, but the inner one not know itself
  /// is a directly child of a generator, so it will have wrong sign, depends
  /// outside pass a correct one to it.
  fn regenerate(&mut self, tree: &mut WidgetTree, sign: Option<WidgetId>) {
    if !self.is_dirty {
      return;
    }
    self.is_dirty = false;

    let sign = sign.unwrap_or_else(|| self.gen_dyn_widgets.first());
    let parent = sign.parent(tree);
    let mut ctx = BuildCtx::new(parent, tree);
    let new_gen = (self.expr)(&mut ctx);

    // Place the real render node in tree, effect lifecycle.
    std::mem::swap(&mut self.self_render, sign.assert_get_mut(tree));
    match (&mut self.gen_dyn_widgets, new_gen) {
      (DynamicWidgetInfo::SingleDynWithChild { depth, first }, DynamicWidget::Single(w)) => {
        *first = sign;
        *depth = refresh_single_with_child(sign, w, *depth, tree)
      }
      (DynamicWidgetInfo::WholeSubtree(gen_widgets), new_widgets) => {
        gen_widgets[0] = sign;
        refresh_multi(gen_widgets, new_widgets, tree)
      }
      _ => unreachable!("generator not match its generate"),
    };

    self.self_render = sign.replace_data(Box::new(Void), tree);
  }
}

fn refresh_single_with_child(
  sign: WidgetId,
  widget: Option<Widget>,
  depth: usize,
  tree: &mut WidgetTree,
) -> usize {
  let p = sign.parent(tree);
  let new_gen_root = widget
    .and_then(|w| w.into_subtree(p, tree))
    // gen root at least have a void widget as road sign.
    .unwrap_or_else(|| tree.empty_node());

  let declare_child_parent = single_down(sign, tree, depth as isize - 1);
  let (new_leaf, down_level) = down_to_leaf(new_gen_root, tree);
  let new_depth = down_level + 1;
  if let Some(declare_child_parent) = declare_child_parent {
    // Safety: control two subtree not intersect.
    let (tree1, tree2) = unsafe { tree.split_tree() };
    declare_child_parent
      .children(tree1)
      .for_each(|c| new_leaf.append(c, tree2));
  }
  sign.insert_after(new_gen_root, tree);

  // we always keep the first dyn widget not change for `Generator`.
  sign.swap_data(new_gen_root, tree);
  sign.swap(new_gen_root, tree);
  // new is swap to old gen root.

  let mut keys = HashSet::default();
  collect_widget_keys(new_gen_root, tree, &mut keys);
  new_gen_root.remove_subtree(tree);
  single_on_mounted(sign, new_depth, tree, keys);

  tree.mark_dirty(new_gen_root);
  depth
}

fn collect_widget_keys(root: WidgetId, tree: &WidgetTree, keys: &mut HashSet<Key>) {
  root.descendants(tree).for_each(|node| {
    node.key(tree).map(|k| keys.insert(k));
  });
}

fn refresh_multi(
  gen_widgets: &mut SmallVec<[WidgetId; 1]>,
  widgets: DynamicWidget,
  tree: &mut WidgetTree,
) {
  let tmp = tree.empty_node();
  let sign = gen_widgets[0];
  sign.insert_before(tmp, tree);
  tmp.swap(sign, tree);
  tmp.swap_data(sign, tree);
  gen_widgets[0] = tmp;

  let parent = sign.parent(tree);
  let mut keys = HashSet::default();
  gen_widgets.iter().for_each(|w| {
    collect_widget_keys(*w, tree, &mut keys);
    w.remove_subtree(tree);
  });
  gen_widgets.clear();

  match widgets {
    DynamicWidget::Single(w) => {
      if let Some(n) = w.and_then(|w| w.into_subtree(parent, tree)) {
        sign.insert_after(n, tree);
        gen_widgets.push(n);
      }
    }
    DynamicWidget::Multi(m) => {
      let mut cursor = sign;
      for w in m.into_iter() {
        if let Some(n) = w.into_subtree(parent, tree) {
          cursor.insert_after(n, tree);
          gen_widgets.push(n);
          cursor = n;
        }
      }
    }
  };

  if gen_widgets.is_empty() {
    gen_widgets.push(sign)
  } else {
    let first = gen_widgets[0];
    first.swap(sign, tree);
    first.swap_data(sign, tree);
    first.remove_subtree(tree);
    gen_widgets[0] = sign;

    gen_widgets.iter().for_each(|n| {
      n.on_mounted_subtree(tree, &keys);
      tree.mark_dirty(*n)
    });
  }
}

impl DynamicWidgetInfo {
  fn first(&self) -> WidgetId {
    match self {
      DynamicWidgetInfo::SingleDynWithChild { first, .. } => *first,
      DynamicWidgetInfo::WholeSubtree(d) => {
        *d.first().expect("dynamic must have at least one child.")
      }
    }
  }
}

fn single_down(id: WidgetId, tree: &WidgetTree, mut down_level: isize) -> Option<WidgetId> {
  let mut res = Some(id);
  while down_level > 0 {
    down_level -= 1;
    res = res.unwrap().single_child(tree);
  }
  res
}

fn down_to_leaf(id: WidgetId, tree: &WidgetTree) -> (WidgetId, usize) {
  let mut leaf = id;
  let mut depth = 0;
  while let Some(c) = leaf.single_child(tree) {
    leaf = c;
    depth += 1;
  }
  (leaf, depth)
}

fn single_on_mounted(
  from: WidgetId,
  mut level: usize,
  tree: &mut WidgetTree,
  keys: HashSet<Key>,
) -> Option<WidgetId> {
  let mut next = Some(from);
  while level > 0 {
    let c = next.unwrap();

    let mount = c
      .key(tree)
      .and_then(|k| keys.get(&k))
      .map_or(MountedType::New, |_| MountedType::Refresh);

    c.on_mounted(tree, mount);
    next = c.single_child(tree);

    level -= 1;
  }
  next
}

#[cfg(test)]
mod tests {
  use crate::prelude::*;
  use crate::widget::{widget_tree::WidgetTree, IntoStateful};
  use std::cell::RefCell;
  use std::rc::Rc;

  #[test]
  fn expr_widget_as_root() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      ExprWidget {
        expr: SizedBox { size: size.clone() },
        Void {}
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 2);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 2);

    assert_eq!(ids[1], new_ids[1]);
  }

  #[test]
  fn expr_widget_with_declare_child() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      SizedBox {
        size: Size::zero(),
        ExprWidget {
          expr: SizedBox { size: size.clone() },
          Void {}
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 3);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 3);

    assert_eq!(ids[0], new_ids[0]);
    assert_eq!(ids[2], new_ids[2]);
  }

  #[test]
  fn expr_widget_mounted_new() {
    let v = vec![1, 2, 3].into_stateful();

    let new_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let refresh_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let w = widget! {
      track { v: v.clone(),
              new_cnt: new_cnt.clone(),
              refresh_cnt: refresh_cnt.clone() }
      Row {
        ExprWidget {
          expr: {
            v.iter().enumerate().map(move |(idx, _)| {
              widget! {
                SizedBox{
                  size: Size::zero(),
                  mounted: move |_, t| {
                    match t {
                      MountedType::New => *new_cnt.borrow_mut() += 1,
                      MountedType::Refresh => *refresh_cnt.borrow_mut() += 1,
                    };
                  }
                }
              }
            }).collect::<Vec<_>>()
          }
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 3);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);

    v.state_ref().push(4);
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 7);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);

    v.state_ref().pop();
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 10);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);
  }

  #[test]
  fn expr_widget_mounted_track() {
    let v = vec![1, 2, 3].into_stateful();

    let new_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let refresh_cnt = Rc::new(RefCell::new(0)).into_stateful();
    let w = widget! {
      track { v: v.clone(),
              new_cnt: new_cnt.clone(),
              refresh_cnt: refresh_cnt.clone() }
      Row {
        ExprWidget {
          expr: {
            v.iter().enumerate().map(move |(idx, _)| {
            widget! {
              SizedBox{
                key: idx,
                size: Size::zero(),
                mounted: move |_, t| {
                  match t {
                    MountedType::New => *new_cnt.borrow_mut() += 1,
                    MountedType::Refresh => *refresh_cnt.borrow_mut() += 1,
                  };
                }
              }
            }
          }).collect::<Vec<_>>()
          }
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 3);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 0);

    v.state_ref().push(4);
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 4);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 3);

    v.state_ref().pop();
    tree.tree_repair();
    assert_eq!(*new_cnt.raw_ref().borrow(), 4);
    assert_eq!(*refresh_cnt.raw_ref().borrow(), 6);
  }
}
