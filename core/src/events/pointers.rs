use super::{impl_common_event, EventCommon};
use crate::{prelude::Point, widget::Widget};
mod from_mouse;
#[derive(Debug)]
pub struct PointerId(usize);

/// The pointer is a hardware-agnostic device that can target a specific set of
/// screen coordinates. Having a single event model for pointers can simplify
/// creating Web sites and applications and provide a good user experience
/// regardless of the user's hardware. However, for scenarios when
/// device-specific handling is desired, pointer events defines a pointerType
/// property to inspect the device type which produced the event.
/// Reference: https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events#term_pointer_event
#[derive(Debug)]
pub struct PointerEvent {
  /// The X, Y coordinate of the pointer in current target widget.
  pub pos: Point,
  // The X, Y coordinate of the mouse pointer in global (window) coordinates.
  pub global_pos: Point,
  /// A unique identifier for the pointer causing the event.
  pub id: PointerId,
  /// The width (magnitude on the X axis), in CSS pixels, of the contact
  /// geometry of the pointer.
  pub width: f32,
  /// the height (magnitude on the Y axis), in CSS pixels, of the contact
  /// geometry of the pointer.
  pub height: f32,
  /// the normalized pressure of the pointer input in the range of 0 to 1, where
  /// 0 and 1 represent the minimum and maximum pressure the hardware is capable
  /// of detecting, respectively. tangentialPressure
  /// The normalized tangential pressure of the pointer input (also known as
  /// barrel pressure or cylinder stress) in the range -1 to 1, where 0 is the
  /// neutral position of the control.
  pub pressure: f32,
  /// The plane angle (in degrees, in the range of -90 to 90) between the Y–Z
  /// plane and the plane containing both the pointer (e.g. pen stylus) axis and
  /// the Y axis.
  pub tilt_x: f32,
  /// The plane angle (in degrees, in the range of -90 to 90) between the X–Z
  /// plane and the plane containing both the pointer (e.g. pen stylus) axis and
  /// the X axis.
  pub tilt_y: f32,
  /// The clockwise rotation of the pointer (e.g. pen stylus) around its major
  /// axis in degrees, with a value in the range 0 to 359.
  pub twist: f32,
  ///  Indicates the device type that caused the event (mouse, pen, touch, etc.)
  pub point_type: PointerType,
  /// Indicates if the pointer represents the primary pointer of this pointer
  /// type.
  pub is_primary: bool,
  /// The buttons being depressed (if any) when the mouse event was fired.
  pub buttons: MouseButtons,
  common: EventCommon,
}

bitflags! {
  pub struct MouseButtons: u8 {
    /// No button or un-initialized
    const NONE = 0b0000_0000;
    /// Primary button (usually the left button)
    const PRIMARY = 0b0000_0001;
    /// Secondary button (usually the right button)
    const SECONDARY = 0b0000_0010;
    /// Auxiliary button (usually the mouse wheel button or middle button)
    const AUXILIARY = 0b0000_0100;
    /// 4th button (typically the "Browser Back" button)
    const FOURTH = 0b0000_1000;
    /// 5th button (typically the "Browser Forward" button)
    const FIFTH = 0b0001_0000;
  }
}

#[derive(Debug)]
pub enum PointerType {
  /// The event was generated by a mouse device.
  Mouse,
  /// The event was generated by a pen or stylus device.
  Pen,
  /// The event was generated by a touch, such as a finger.
  Touch,
}

impl_common_event!(PointerEvent, common);

impl PointerEvent {
  /// The button number that was pressed (if applicable) when the mouse event
  /// was fired.
  pub fn button_num(&self) -> usize { unimplemented!() }
}

/// A widget that calls callbacks in response to common pointer events.
pub struct PointerListener {
  pub child: Box<dyn Widget>,
  pub on_pointer_down: Option<Box<dyn Fn(&PointerEvent)>>,
  pub on_pointer_move: Option<Box<dyn Fn(&PointerEvent)>>,
  pub on_pointer_up: Option<Box<dyn Fn(&PointerEvent)>>,
  pub on_pointer_cancel: Option<Box<dyn Fn(&PointerEvent)>>,
  /* onpointerover:
   * onpointerenter:
   * onpointerout:
   * onpointerleave:
   * gotpointercapture:
   * lostpointercapture: */
}

impl PointerListener {
  pub fn listen_on<W: Into<Box<dyn Widget>>>(w: W) -> Self {
    Self {
      child: w.into(),
      on_pointer_down: None,
      on_pointer_move: None,
      on_pointer_up: None,
      on_pointer_cancel: None,
    }
  }

  #[inline]
  pub fn on_pointer_down<F: Into<Box<dyn Fn(&PointerEvent)>>>(&mut self, handler: F) -> &mut Self {
    self.on_pointer_down = Some(handler.into());
    self
  }

  #[inline]
  pub fn on_pointer_up<F: Into<Box<dyn Fn(&PointerEvent)>>>(&mut self, handler: F) -> &mut Self {
    self.on_pointer_up = Some(handler.into());
    self
  }

  #[inline]
  pub fn on_pointer_move<F: Into<Box<dyn Fn(&PointerEvent)>>>(&mut self, handler: F) -> &mut Self {
    self.on_pointer_move = Some(handler.into());
    self
  }

  #[inline]
  pub fn on_pointer_cancel<F: Into<Box<dyn Fn(&PointerEvent)>>>(
    &mut self,
    handler: F,
  ) -> &mut Self {
    self.on_pointer_cancel = Some(handler.into());
    self
  }

  pub(crate) fn dispatch_pointer_down(&self, event: &PointerEvent) {
    log::info!("dispatch pointer down: {:?}", event);
    if let Some(ref cb) = self.on_pointer_down {
      cb(event)
    }
  }

  pub(crate) fn dispatch_pointer_up(&self, event: &PointerEvent) {
    log::info!("dispatch pointer up: {:?}", event);
    if let Some(ref cb) = self.on_pointer_up {
      cb(event)
    }
  }

  pub(crate) fn dispatch_pointer_move(&self, event: &PointerEvent) {
    log::info!("dispatch pointer move: {:?}", event);
    if let Some(ref cb) = self.on_pointer_move {
      cb(event)
    }
  }

  pub(crate) fn dispatch_pointer_cancel(&self, event: &PointerEvent) {
    log::info!("dispatch pointer cancel: {:?}", event);
    if let Some(ref cb) = self.on_pointer_cancel {
      cb(event)
    }
  }
}
