use super::{
  atlas::TextureAtlas, error::CanvasError, layer_2d, text_brush::TextBrush, DevicePoint,
  DeviceSize, FillStyle, RenderAttr, RenderCommand, Rendering2DLayer,
};

use zerocopy::AsBytes;

enum PrimaryBindings {
  GlobalUniform = 0,
  TextureAtlas = 1,
  GlyphTexture = 2,
  Sampler = 3,
}

enum SecondBindings {
  Primitive = 0,
}

pub struct CanvasOptions {
  texture_max_size: DeviceSize,
  texture_init_size: DeviceSize,
}
pub struct Canvas {
  // texture atlas for pure color and image to draw.
  atlas: TextureAtlas,
  glyph_brush: TextBrush,
  render_data: RenderData,
  options: CanvasOptions,
}

/// An identify of a layer, generated by a layer composed. Use this to fast
/// compose the same layer after the first compose.
pub struct LayerID;

/// The Render that support draw the canvas result render data.
pub trait Canvas2DRender {
  fn new() -> Self;
  fn draw(&mut self);
}

impl Canvas {
  /// The brush canvas use to draw text, can use it to mange fonts.
  #[inline]
  pub fn text_brush(&mut self) -> &mut TextBrush { &mut self.glyph_brush }

  /// Create a 2d layer to drawing, and not effect current canvas before compose
  /// back to the canvas.
  #[inline]
  pub fn new_2d_layer<'l>(&self) -> Rendering2DLayer<'l> { Rendering2DLayer::new() }

  /// Compose a layer into the canvas.
  pub fn compose_2d_layer(&mut self, layer: Rendering2DLayer) -> Result<LayerID, CanvasError> {
    unimplemented!();
    // first, store all resource to texture, then generate vertices.
  }

  /// Fast compose a layer by cache. Return `CanvasError::InValidLayerID` if the
  /// layer id unavailable.
  pub fn compose_layer_by_id(&mut self, id: LayerID) -> Result<(), CanvasError> {
    unimplemented!();
  }

  /// Like [`Canvas::compose_layer_by_id`](Canvas::compose_layer_by_id), it's do
  /// compose the layer into canvas. But `compose_2d_layer_with_render` method
  /// require a render to ensure this layer compose not failure.
  /// Use `compose_2d_layer` if you know this layer is not use too much image
  /// and not draw large text.
  ///
  /// This method will submit render data early if the texture space is not
  /// enough to store the `layer`'s resource. And also may split the layer as
  /// many pieces to submit to `render` one by one.
  ///
  /// Return the layer id if the layer not be broken up. Otherwise, `None` will
  /// be returned.
  pub fn compose_2d_layer_with_render<R: Canvas2DRender>(
    &mut self,
    layer: Rendering2DLayer,
    render: &mut R,
  ) -> Option<LayerID> {
    let RenderCommand { attrs, geometry } = layer.finish(self)?;

    let layer_broken = false;
    let mut v_start: usize = 0;
    let mut i_start: usize = 0;
    let mut indices_offset = self.render_data.vertices.len() as i32;
    attrs.iter().for_each(
      |RenderAttr {
         transform,
         count,
         style,
         align_bounds,
       }| {
        let res = self.store_style_in_atlas(style).or_else(|err| {
          self.submit(render);
          layer_broken = true;
          // Todo: we should not directly clear the texture atlas,
          // but deallocate all not used texture.
          self.atlas.clear();
          indices_offset = -(v_start as i32);
          match err {
            CanvasError::TextureSpaceNotEnough => {
              let res = self.store_style_in_atlas(style);
              debug_assert!(res.is_ok());
              res
            }
            CanvasError::ResourceOverTheMaxLimit => {
              unimplemented!("draw current attr individual");
              // Err(err)
            }
            CanvasError::InValidLayerID => {
              unreachable!();
            }
          }
        });

        let v_end = v_start + count.vertices as usize;
        let i_end = i_start + count.indices as usize;

        // Error already processed before, needn't care about it.
        if let Ok((tex_offset, tex_size)) = res {
          let tex_info = Primitive {
            tex_offset: [tex_offset.x, tex_offset.y],
            tex_size: [tex_size.width, tex_size.height],
            transform: transform.to_row_arrays(),
            bound_min: align_bounds.min().to_array(),
            bounding_size: align_bounds.size.to_array(),
          };

          self.render_data.append(
            indices_offset,
            &geometry.vertices[v_start..v_end],
            &geometry.indices[i_start..i_end],
            tex_info,
          )
        }

        v_start = v_end;
        i_start = i_end;
      },
    );

    if layer_broken { None } else { Some(LayerID) }
  }

  /// Submit all render data to Render to draw,
  pub fn submit<R: Canvas2DRender>(&mut self, render: &mut R) {
    unimplemented!();
  }

  fn store_style_in_atlas(
    &mut self,
    style: &FillStyle,
  ) -> Result<(DevicePoint, DeviceSize), CanvasError> {
    let (pos, size) = match style {
      FillStyle::Color(c) => {
        let pos = self.atlas.store_color(c.clone())?;

        (pos, DeviceSize::new(1, 1))
      }
      _ => todo!("not support in early develop"),
    };

    Ok((pos, size))
  }
}

#[derive(Default)]
struct RenderData {
  vertices: Vec<Vertex>,
  indices: Vec<u32>,
  primitives: Vec<Primitive>,
}

#[repr(C)]
#[derive(AsBytes)]
struct Primitive {
  // Texture offset in texture atlas.
  tex_offset: [u32; 2],
  // Texture size in texture atlas.
  tex_size: [u32; 2],
  bound_min: [f32; 2],
  bounding_size: [f32; 2],
  transform: [[f32; 2]; 3],
}

/// We use a texture atlas to shader vertices, even if a pure color path.
#[repr(C)]
#[derive(Copy, Clone, Debug, AsBytes)]
struct Vertex {
  pixel_coords: [f32; 2],
  texture_coors: [f32; 2],
  tex_id: u32,
}

impl RenderData {
  #[inline]
  fn has_data(&self) -> bool {
    // fixme: open the below assert, draw same text's attr is incorrect.
    // debug_assert_eq!(self.vertices.is_empty(), self.indices.is_empty());
    // debug_assert_eq!(self.vertices.is_empty(), self.primitives.is_empty());

    !self.vertices.is_empty()
  }

  fn clear(&mut self) {
    self.vertices.clear();
    self.indices.clear();
    self.primitives.clear();
  }

  fn append(
    &mut self,
    indices_offset: i32,
    vertices: &[layer_2d::Vertex],
    indices: &[u32],
    tex_info: Primitive,
  ) {
    let tex_id = self.primitives.len() as u32;
    self.primitives.push(tex_info);

    let mapped_indices = indices.iter().map(|index| {
      let index = *index as i32 + indices_offset;
      debug_assert!(index >= 0);
      index as u32
    });
    self.indices.extend(mapped_indices);

    let mapped_vertices = vertices.iter().map(|v| Vertex {
      pixel_coords: v.pixel_coords.to_array(),
      texture_coors: v.texture_coords.to_array(),
      tex_id,
    });
    self.vertices.extend(mapped_vertices);
  }
}

impl Default for CanvasOptions {
  #[inline]
  fn default() -> Self {
    Self {
      texture_init_size: DeviceSize::new(1024, 1024),
      texture_max_size: DeviceSize::new(4096, 4096),
    }
  }
}
